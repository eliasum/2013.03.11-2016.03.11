/************************************************************************************************************/
/*                                                                                                          */
/*                          Управляющая программа для ATmega1280 в проекте "Апертура"                       */
/*                                       Версия 1.0 (2014.07.10_16-06)                                      */
/*                                                                                                          */
/************************************************************************************************************/
#include "main.h"
#include <math.h>     
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
/*                                                                                                          */
/*                                        Главная функция программы                                         */
/*                                                                                                          */
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
void main( void )
{
  // задание интервала сброса WDT: 
  __watchdog_reset();                        // WDTCSR = WDIF WDIE WDP3 WDCE WDE WDP2 WDP1 WDP0 (XXXX XXXX)
  WDTCSR |= (1<<WDCE) | (1<<WDE);            // разрешение настройки/системного сброса WDT      (XXX1 1XXX)
  WDTCSR  = (1<<WDE)  | (1<<WDP3);           // установка тайм-аута = 512K циклов (~ 4.0 с)     (0010 1000)  
  
  // инициализация портов:
  DDRA = (1<<IN1_01)|(1<<IN1_02)|(1<<IN1_03)|(1<<IN1_04)|(1<<IN1_05)|(1<<IN1_06)|(1<<IN1_07)|(1<<IN1_08); // выходы
  
  PORTB = (1<<IN_SS0)|(1<<IN_SS1)|(1<<IN_SS2); // 1 на выходе
  DDRB = (1<<IN_SS0)|(1<<IN_SCK)|(1<<IN_MOSI)|(1<<IN_SS1)|(1<<IN_SS2)|(1<<IN_LE); // выходы
  
  DDRC = (1<<IN1_09)|(1<<IN1_10)|(1<<IN1_11)|(1<<IN1_12)|(1<<IN1_13)|(1<<IN1_14)|(1<<IN1_15)|(1<<IN1_16); // выходы

  DDRD = (1<<IN2_01)|(1<<IN2_02)|(1<<IN2_03)|(1<<IN2_04)|(1<<IN2_05)|(1<<IN2_06)|(1<<IN2_07)|(1<<IN2_08); // выходы

  PORTE = (1<<RX)|(1<<TX); // подтяжка на питание или 1 на выходе
  DDRE = (1<<TX)|(1<<ADLIN1_D0)|(1<<ADLIN1_D1)|(1<<ADLIN1_D2)|(1<<ADLIN1_D3)|(1<<ADLIN1_D4)|(1<<ADLIN1_D5); // выходы

  DDRF = (1<<ADLIN1_D6)|(1<<ADLIN2_D0)|(1<<ADLIN2_D1)|(1<<ADLIN2_D2)|(1<<ADLIN2_D3)|(1<<ADLIN2_D4)|(1<<ADLIN2_D5)|(1<<ADLIN2_D6); // выходы
  
  PORTG = (1<<LED); // 1 на выходе
  DDRG = (1<<IN4_09)|(1<<IN4_10)|(1<<IN4_11)|(1<<IN4_12)|(1<<IN4_13)|(1<<LED); // выходы
  
  DDRH = (1<<IN2_09)|(1<<IN2_10)|(1<<IN2_11)|(1<<IN2_12)|(1<<IN2_13)|(1<<IN2_14)|(1<<IN2_15)|(1<<IN2_16); // выходы
  
  DDRJ = (1<<IN3_01)|(1<<IN3_02)|(1<<IN3_03)|(1<<IN3_04)|(1<<IN3_05)|(1<<IN3_06)|(1<<IN3_07)|(1<<IN3_08); // выходы

  DDRK = (1<<IN3_09)|(1<<IN3_10)|(1<<IN3_11)|(1<<IN3_12)|(1<<IN3_13)|(1<<IN3_14)|(1<<IN3_15)|(1<<IN3_16); // выходы

  DDRL = (1<<IN4_01)|(1<<IN4_02)|(1<<IN4_03)|(1<<IN4_04)|(1<<IN4_05)|(1<<IN4_06)|(1<<IN4_07)|(1<<IN4_08); // выходы

  count_bod = 1;                             // минимум 1 прерывание
  t_led_on  = 0;                             // время индикации
  
  __watchdog_reset();                        // 1-й "простой" cброс сторожевого таймера
  __enable_interrupt();                      // прерывания разрешаем
  
  // инициализация USART (2400):
  UCSR0A = 0x00;                             // запрет настроек USART на время установки скорости передачи
  UCSR0B = 0x00;                             
  UCSR0C = 0x06;                             // размер слова данных 8 бит
  UBRR0L = UBBR_2K4L;                        // задание скорости 57600
  UBRR0H = UBBR_2K4H;   
  UCSR0B = 0x08;                             // разрешение передачи (TXENn = 1)

  // инициализация Т/С0:
  TCCR0B = 0x00;                             // останов Т/С0
  TCNT0  = RELOAD_TIM0;                      // нач. знач-е
  TCCR0A = 0x00;
  TCCR0B = START_TIM0;                       // таймер запускаем
  TIMSK0 = 0x01;                             // Т/С0 <- источник прерываний
    
  SPI_MasterInit();                          // инициализация SPI в режиме Master
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
          
                                   //Организация работы линии обмена                   
          
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
  Перед началом передачи пакета данных всегда есть синхропауза (логическая 1). Это нужно для безошибочной работы
  по линии, т.к. система асинхронная и ведомое устройство может включиться не одновременно с ведущим устройством. 
  Даже если устройство включится уже после начала передачи ведущим, оно примет данные только после "полной" 
  синхропаузы, которую будет ожидать. Длина синхропаузы больше, чем длина одного слова данных.
  Применение асинхронной системы позволяет использовать простой канал связи, который гораздо дешевле, чем при 
  синхронной системе. 
*/    
  for (;;)
  {     
    UCSR0B &= ~(1<<RXEN0);                   // отключение приемника USART
    count_bod = CBOD;                        // счетчик БОД

    do
    {
      if (!(PINE & (1<<RX))) count_bod = CBOD;
    } while (count_bod);                     // ожидание СИНХРО-ПАУЗЫ (всегда только перед командой)
/*
    Выполнять присваивание count_bod = CBOD = 4, если RX = 0, пока count_bod - истина. Если же в течение четырёх
    периодов переполнения таймера0 с частотой 600 Гц, т.е. 6.7 мс, будет выполнено условие RX = 1, тогда
    программа уменьшит значение count_bod до нуля, условие while (count_bod) станет ложным и произойдёт 
    выход из цикла do/while. Только теперь устройство включится на приём. Таким образом, значение синхропаузы 
    составляет 6.7 мс. Начало приёма происходит при обнаружении старт-бита (логический 0).
*/    
    // приём данных по UART:
/*
    Вперёд старший регистр. Вперёд старший байт.
*/
    UCSR0B |= (1<<RXEN0);                    // включение приемника USART
     
    while (!(UCSR0A & (1<<RXC0)));           // ждем завершение приема байта
    
    unsigned char var;                       // маркер передачи на контроллер
    var=UDR0;                                // UDRn - USART I/O Data Register n
    
    for(int i=0; i<1604; i++)                // приём 27-и команд по UART
    {
      while (!(UCSR0A & (1<<RXC0)));         // ждем завершение приема байта
      R[i] = UDR0;                           // Command3[0][0], Command3[0][1],...,Com6[3],...Com20[3]
    }

    if(var==0x55)                            // если маркер передачи на синтезатор и фильтры
    {  
      t_led_on  = T_LED_ON;                  // время подсвечивания
      LED_ON;   
    
      // передача данных по SPI на ППРМ-2:
/*    
      Передача команд:
      0...767 пропустить
      768...775 передать
      776...1543 пропустить
      1544...1603 передать
      
*/     
      // Режим "Работа":
      // Команда "Параметры СВЧ тракта":
      SPI_Write(0x03);                       // байт кода команды
      SPI_Write(0x00);                       // первый байт пакета данных      
      SPI_Write(R[770]);                     // второй байт пакета данных       
      SPI_Write(R[771]);                     // третий байт пакета данных       
      SPI_Write(R[775]);                     // четвертый байт пакета данных  
      
      // Режим "Контроль":
      // Команда "Коэффициент ослабления приёмника и передатчика ППРМ-2":      
      SPI_Write(0xE3);                       // байт кода команды
      SPI_Write(0x00);                       // первый байт пакета данных      
      SPI_Write(0x00);                       // второй байт пакета данных       
      SPI_Write(R[1551]);                    // третий байт пакета данных       
      SPI_Write(R[1547]);                    // четвертый байт пакета данных        

      // Команда "Частота среза фильтра гетеродина приёмника и передатчика ППРМ-2":      
      SPI_Write(0xE4);                       // байт кода команды
      SPI_Write(R[1558]);                    // первый байт пакета данных      
      SPI_Write(R[1559]);                    // второй байт пакета данных       
      SPI_Write(R[1554]);                    // третий байт пакета данных       
      SPI_Write(R[1545]);                    // четвертый байт пакета данных          
      
      // Команда "Параметры СВЧ тракта":      
      SPI_Write(0xE5);                       // байт кода команды
      SPI_Write(0x00);                       // первый байт пакета данных      
      SPI_Write(R[1571]);                    // второй байт пакета данных       
      SPI_Write(R[1563]);                    // третий байт пакета данных       
      SPI_Write(R[1567]);                    // четвертый байт пакета данных         
      
      // Команда "Рабочие регистры синтезатора платы ППРМ-2. Пакет 1":      
      SPI_Write(0xE6);                       // байт кода команды
      SPI_Write(R[1573]);                    // первый байт пакета данных      
      SPI_Write(R[1574]);                    // второй байт пакета данных       
      SPI_Write(R[1575]);                    // третий байт пакета данных       
      SPI_Write(R[1577]);                    // четвертый байт пакета данных       
      
      // Команда "Рабочие регистры синтезатора платы ППРМ-2. Пакет 2":      
      SPI_Write(0xE7);                       // байт кода команды
      SPI_Write(R[1578]);                    // первый байт пакета данных      
      SPI_Write(R[1579]);                    // второй байт пакета данных       
      SPI_Write(R[1581]);                    // третий байт пакета данных       
      SPI_Write(R[1582]);                    // четвертый байт пакета данных       
      
      // Команда "Рабочие регистры синтезатора платы ППРМ-2. Пакет 3":      
      SPI_Write(0xE8);                       // байт кода команды
      SPI_Write(R[1583]);                    // первый байт пакета данных      
      SPI_Write(R[1585]);                    // второй байт пакета данных       
      SPI_Write(R[1586]);                    // третий байт пакета данных       
      SPI_Write(R[1587]);                    // четвертый байт пакета данных         
      
      // Команда "Рабочие регистры синтезатора платы ППРМ-2. Пакет 4":      
      SPI_Write(0xE9);                       // байт кода команды
      SPI_Write(R[1589]);                    // первый байт пакета данных      
      SPI_Write(R[1590]);                    // второй байт пакета данных       
      SPI_Write(R[1591]);                    // третий байт пакета данных       
      SPI_Write(R[1593]);                    // четвертый байт пакета данных       
      
      // Команда "Рабочие регистры синтезатора платы ППРМ-2. Пакет 5":      
      SPI_Write(0xEA);                       // байт кода команды
      SPI_Write(R[1594]);                    // первый байт пакета данных      
      SPI_Write(R[1595]);                    // второй байт пакета данных       
      SPI_Write(R[1597]);                    // третий байт пакета данных       
      SPI_Write(R[1598]);                    // четвертый байт пакета данных  

      // Команда "Рабочие регистры синтезатора платы ППРМ-2. Пакет 6":      
      SPI_Write(0xEB);                       // байт кода команды
      SPI_Write(R[1599]);                    // первый байт пакета данных      
      SPI_Write(R[1601]);                    // второй байт пакета данных       
      SPI_Write(R[1602]);                    // третий байт пакета данных       
      SPI_Write(R[1603]);                    // четвертый байт пакета данных
    }
    __watchdog_reset();
  }
}
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
/*                                                                                                          */
/*                                               Подпрограммы                                               */
/*                                                                                                          */
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
#pragma vector=TIMER0_OVF_vect         // директива определяет вектор функции прерывания, описание которой следует за ней                 
__interrupt void timer0_ovf_isr(void)  // функция прерывания по переполнению таймера0 
{
  //TIMER0 has overflowed
  TCNT0  = RELOAD_TIM0;                // reload counter value

  if (count_bod)  count_bod--;

  if(t_led_on)  t_led_on--;            // время подсвечивания --
  else          LED_OFF;               // LED-OFF
/*
  Частота переполнения таймера0 SYSTEM_TICK выбрана 600 Гц. Поэтому период переполнения таймера0 Tovf 
  составляет 1.7 мс, а константа перезагрузки 'TIM0' составляет RELOAD_TIM0 = 152(0x98). Подпрограмма 
  обработки прерывания по переполнению таймера0 вызывается каждые 1.7 мс, заново загружает константу 
  перезагрузки 'TIM0' и каждый раз уменьшает значение count_bod и t_led_on на единицу, пока значение 
  count_bod > 0 и t_led_on > 0. 
  Время горения светодиода будет T_LED_ON*Tovf = 120*1.7мс = 0.2c.
*/
}

// Подпрограмма инициализации SPI в режиме Master
void SPI_MasterInit(void)
{
/* 
  - Разрешение SPI в режиме мастера,
  - CPOL = 1 - генерируются тактовые импульсы отрицательной полярности,
  - CPHA = 0 - обработка данных производится по переднему спадающему фронту импульсов сигнала SCK,
  - установка скорости обмена fck/128=16МГц/128=125кГц 
*/
  SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0)|(1<<CPOL);
}

// Подпрограмма записи по SPI
void SPI_Write(unsigned char dataout)
{
  // Запись байта в регист данных ведущего (инициализация передачи)
  SPDR = dataout;
  // Ожидание завершения передачи (пока бит SPIF не установлен)
  while(!(SPSR & (1<<SPIF)));
}