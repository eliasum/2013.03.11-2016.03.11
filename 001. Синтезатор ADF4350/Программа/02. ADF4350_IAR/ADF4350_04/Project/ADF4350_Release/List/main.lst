###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.50.0.50277/W32 for Atmel AVR    05/Feb/2014  17:05:14 #
# Copyright (C) 1996-2010 IAR Systems AB.                                     #
#                                                                             #
#    Source file  =  d:\_IAR projects\ADF4350_IAR_ver.1\ADF4350_05\main.c     #
#    Command line =  "d:\_IAR projects\ADF4350_IAR_ver.1\ADF4350_05\main.c"   #
#                    --cpu=m1280 -ms -o "d:\_IAR                              #
#                    projects\ADF4350_IAR_ver.1\ADF4350_05\Project\ADF4350_Re #
#                    lease\Obj\" -D NDEBUG -lCN "d:\_IAR                      #
#                    projects\ADF4350_IAR_ver.1\ADF4350_05\Project\ADF4350_Re #
#                    lease\List\" -y --initializers_in_flash -s2 --no_cse     #
#                    --no_inline --no_code_motion --no_cross_call             #
#                    --no_clustering --no_tbaa -DENABLE_BIT_DEFINITIONS -e    #
#                    -I "F:\Program Files\IAR Systems\Embedded Workbench      #
#                    5.4\avr\INC\" -I "F:\Program Files\IAR Systems\Embedded  #
#                    Workbench 5.4\avr\INC\CLIB\" --eeprom_size 4096          #
#    List file    =  d:\_IAR projects\ADF4350_IAR_ver.1\ADF4350_05\Project\AD #
#                    F4350_Release\List\main.lst                              #
#    Object file  =  d:\_IAR projects\ADF4350_IAR_ver.1\ADF4350_05\Project\AD #
#                    F4350_Release\Obj\main.r90                               #
#                                                                             #
#                                                                             #
###############################################################################

d:\_IAR projects\ADF4350_IAR_ver.1\ADF4350_05\main.c
      1          /************************************************************************************************************/
      2          /*                                                                                                          */
      3          /*                      Управляющая программа для ATmega1280 в проекте "Интерфейс ADF4350"                  */
      4          /*                                       Версия 1.5 (2014.02.05_17-02)                                      */
      5          /*                                                                                                          */
      6          /************************************************************************************************************/
      7          #include "main.h"

   \                                 In  segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash Title[51]
   \                     Title:
   \   00000000   444134463533       DC8 41H, 44H, 46H, 34H, 33H, 35H, 30H, 20H
   \              2030        
   \   00000008   202D69576564       DC8 2DH, 20H, 57H, 69H, 64H, 65H, 62H, 61H
   \              6162        
   \   00000010   646E53206E79       DC8 6EH, 64H, 20H, 53H, 79H, 6EH, 74H, 68H
   \              6874        
   \   00000018   73657A697265       DC8 65H, 73H, 69H, 7AH, 65H, 72H, 20H, 77H
   \              7720        
   \   00000020   746920686E49       DC8 69H, 74H, 68H, 20H, 49H, 6EH, 74H, 65H
   \              6574        
   \   00000028   726774616465       DC8 67H, 72H, 61H, 74H, 65H, 64H, 20H, 56H
   \              5620        
   \   00000030   4F4300             DC8 43H, 4FH, 0

   \                                 In  segment ABSOLUTE, at 0x10a
   \   <__C51> volatile __ext_io _A_DDRL
   \                     _A_DDRL:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x107
   \   <__C60> volatile __ext_io _A_DDRK
   \                     _A_DDRK:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x104
   \   <__C69> volatile __ext_io _A_DDRJ
   \                     _A_DDRJ:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x101
   \   <__C78> volatile __ext_io _A_DDRH
   \                     _A_DDRH:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc6
   \   <__C115> volatile __io _A_UDR0
   \                     _A_UDR0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc4
   \   <__C119> volatile __io _A_UBRR0
   \                     _A_UBRR0:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0xc2
   \   <__C123> volatile __io _A_UCSR0C
   \                     _A_UCSR0C:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc1
   \   <__C126> volatile __io _A_UCSR0B
   \                     _A_UCSR0B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc0
   \   <__C129> volatile __io _A_UCSR0A
   \                     _A_UCSR0A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x6e
   \   <__C293> volatile __io _A_TIMSK0
   \                     _A_TIMSK0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x60
   \   <__C325> volatile __io _A_WDTCSR
   \                     _A_WDTCSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x4e
   \   <__C359> volatile __io _A_SPDR
   \                     _A_SPDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x4d
   \   <__C362> volatile __io _A_SPSR
   \                     _A_SPSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x4c
   \   <__C365> volatile __io _A_SPCR
   \                     _A_SPCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x46
   \   <__C375> volatile __io _A_TCNT0
   \                     _A_TCNT0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x45
   \   <__C378> volatile __io _A_TCCR0B
   \                     _A_TCCR0B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x44
   \   <__C381> volatile __io _A_TCCR0A
   \                     _A_TCCR0A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x34
   \   <__C425> volatile __io _A_PORTG
   \                     _A_PORTG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x33
   \   <__C428> volatile __io _A_DDRG
   \                     _A_DDRG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x31
   \   <__C434> volatile __io _A_PORTF
   \                     _A_PORTF:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x30
   \   <__C437> volatile __io _A_DDRF
   \                     _A_DDRF:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2e
   \   <__C443> volatile __io _A_PORTE
   \                     _A_PORTE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2d
   \   <__C446> volatile __io _A_DDRE
   \                     _A_DDRE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2c
   \   <__C449> volatile __io _A_PINE
   \                     _A_PINE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2a
   \   <__C455> volatile __io _A_DDRD
   \                     _A_DDRD:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x27
   \   <__C464> volatile __io _A_DDRC
   \                     _A_DDRC:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x25
   \   <__C470> volatile __io _A_PORTB
   \                     _A_PORTB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x24
   \   <__C473> volatile __io _A_DDRB
   \                     _A_DDRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x21
   \   <__C482> volatile __io _A_DDRA
   \                     _A_DDRA:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char count
   \                     count:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char volatile count_bod
   \                     count_bod:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char volatile t_led_on
   \                     t_led_on:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char R[28]
   \                     R:
   \   00000000                      DS8 28

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char Z[28]
   \                     `Z`:
   \   00000000                      DS8 28

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char F[28]
   \                     F:
   \   00000000                      DS8 28
      8          #include <math.h>     
      9          /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
     10          /*                                                                                                          */
     11          /*                                        Главная функция программы                                         */
     12          /*                                                                                                          */
     13          /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

   \                                 In  segment CODE, align 2, keep-with-next
     14          void main( void )
   \                     main:
     15          {
   \   00000000   ........           CALL    ?PROLOGUE7_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
     16            // задание интервала сброса WDT: 
     17            __watchdog_reset();                        // WDTCSR = WDIF WDIE WDP3 WDCE WDE WDP2 WDP1 WDP0 (XXXX XXXX)
   \   00000004   95A8               WDR
     18            WDTCSR |= (1<<WDCE) | (1<<WDE);            // разрешение настройки/системного сброса WDT      (XXX1 1XXX)
   \   00000006   9100....           LDS     R16, _A_WDTCSR
   \   0000000A   6108               ORI     R16, 0x18
   \   0000000C   9300....           STS     _A_WDTCSR, R16
     19            WDTCSR  = (1<<WDE)  | (1<<WDP3);           // установка тайм-аута = 512K циклов (~ 4.0 с)     (0010 1000)  
   \   00000010   E208               LDI     R16, 40
   \   00000012   9300....           STS     _A_WDTCSR, R16
     20            
     21            // инициализация портов:
     22            DDRA = (1<<IN1_01)|(1<<IN1_02)|(1<<IN1_03)|(1<<IN1_04)|(1<<IN1_05)|(1<<IN1_06)|(1<<IN1_07)|(1<<IN1_08); // выходы
   \   00000016   EF0F               LDI     R16, 255
   \   00000018   B901               OUT     0x01, R16
     23            
     24            PORTB = (1<<IN_SS0)|(1<<IN_SS1)|(1<<IN_SS2); // 1 на выходе
   \   0000001A   E301               LDI     R16, 49
   \   0000001C   B905               OUT     0x05, R16
     25            DDRB = (1<<IN_SS0)|(1<<IN_SCK)|(1<<IN_MOSI)|(1<<IN_SS1)|(1<<IN_SS2)|(1<<IN_LE); // выходы
   \   0000001E   E707               LDI     R16, 119
   \   00000020   B904               OUT     0x04, R16
     26            
     27            DDRC = (1<<IN1_09)|(1<<IN1_10)|(1<<IN1_11)|(1<<IN1_12)|(1<<IN1_13)|(1<<IN1_14)|(1<<IN1_15)|(1<<IN1_16); // выходы
   \   00000022   EF0F               LDI     R16, 255
   \   00000024   B907               OUT     0x07, R16
     28          
     29            DDRD = (1<<IN2_01)|(1<<IN2_02)|(1<<IN2_03)|(1<<IN2_04)|(1<<IN2_05)|(1<<IN2_06)|(1<<IN2_07)|(1<<IN2_08); // выходы
   \   00000026   EF0F               LDI     R16, 255
   \   00000028   B90A               OUT     0x0A, R16
     30          
     31            PORTE = (1<<RX)|(1<<TX); // подтяжка на питание или 1 на выходе
   \   0000002A   E003               LDI     R16, 3
   \   0000002C   B90E               OUT     0x0E, R16
     32            DDRE = (1<<TX)|(1<<ADLIN1_D0)|(1<<ADLIN1_D1)|(1<<ADLIN1_D2)|(1<<ADLIN1_D3)|(1<<ADLIN1_D4)|(1<<ADLIN1_D5); // выходы
   \   0000002E   EF0E               LDI     R16, 254
   \   00000030   B90D               OUT     0x0D, R16
     33          
     34            DDRF = (1<<ADLIN1_D6)|(1<<ADLIN2_D0)|(1<<ADLIN2_D1)|(1<<ADLIN2_D2)|(1<<ADLIN2_D3)|(1<<ADLIN2_D4)|(1<<ADLIN2_D5)|(1<<ADLIN2_D6); // выходы
   \   00000032   EF0F               LDI     R16, 255
   \   00000034   BB00               OUT     0x10, R16
     35            
     36            PORTG = (1<<LED); // 1 на выходе
   \   00000036   E200               LDI     R16, 32
   \   00000038   BB04               OUT     0x14, R16
     37            DDRG = (1<<IN4_09)|(1<<IN4_10)|(1<<IN4_11)|(1<<IN4_12)|(1<<IN4_13)|(1<<LED); // выходы
   \   0000003A   E30F               LDI     R16, 63
   \   0000003C   BB03               OUT     0x13, R16
     38            
     39            DDRH = (1<<IN2_09)|(1<<IN2_10)|(1<<IN2_11)|(1<<IN2_12)|(1<<IN2_13)|(1<<IN2_14)|(1<<IN2_15)|(1<<IN2_16); // выходы
   \   0000003E   EF0F               LDI     R16, 255
   \   00000040   9300....           STS     _A_DDRH, R16
     40            
     41            DDRJ = (1<<IN3_01)|(1<<IN3_02)|(1<<IN3_03)|(1<<IN3_04)|(1<<IN3_05)|(1<<IN3_06)|(1<<IN3_07)|(1<<IN3_08); // выходы
   \   00000044   EF0F               LDI     R16, 255
   \   00000046   9300....           STS     _A_DDRJ, R16
     42          
     43            DDRK = (1<<IN3_09)|(1<<IN3_10)|(1<<IN3_11)|(1<<IN3_12)|(1<<IN3_13)|(1<<IN3_14)|(1<<IN3_15)|(1<<IN3_16); // выходы
   \   0000004A   EF0F               LDI     R16, 255
   \   0000004C   9300....           STS     _A_DDRK, R16
     44          
     45            DDRL = (1<<IN4_01)|(1<<IN4_02)|(1<<IN4_03)|(1<<IN4_04)|(1<<IN4_05)|(1<<IN4_06)|(1<<IN4_07)|(1<<IN4_08); // выходы
   \   00000050   EF0F               LDI     R16, 255
   \   00000052   9300....           STS     _A_DDRL, R16
     46          
     47            count_bod = 1;                             // минимум 1 прерывание
   \   00000056   E001               LDI     R16, 1
   \   00000058   9300....           STS     count_bod, R16
     48            t_led_on  = 0;                             // время индикации
   \   0000005C   E000               LDI     R16, 0
   \   0000005E   9300....           STS     t_led_on, R16
     49            
     50            __watchdog_reset();                        // 1-й "простой" cброс сторожевого таймера
   \   00000062   95A8               WDR
     51            __enable_interrupt();                      // прерывания разрешаем
   \   00000064   9478               SEI
     52            
     53            // инициализация USART (2400):
     54            UCSR0A = 0x00;                             // запрет настроек USART на время установки скорости передачи
   \   00000066   E000               LDI     R16, 0
   \   00000068   9300....           STS     _A_UCSR0A, R16
     55            UCSR0B = 0x00;                             
   \   0000006C   E000               LDI     R16, 0
   \   0000006E   9300....           STS     _A_UCSR0B, R16
     56            UCSR0C = 0x06;                             // размер слова данных 8 бит
   \   00000072   E006               LDI     R16, 6
   \   00000074   9300....           STS     _A_UCSR0C, R16
     57            UBRR0L = UBBR_2K4L;                        // задание скорости 2400
   \   00000078   E90F               LDI     R16, 159
   \   0000007A   9300....           STS     _A_UBRR0, R16
     58            UBRR0H = UBBR_2K4H;   
   \   0000007E   E001               LDI     R16, 1
   \   00000080   930000C5           STS     197, R16
     59            UCSR0B = 0x08;                             // разрешение передачи (TXENn = 1)
   \   00000084   E008               LDI     R16, 8
   \   00000086   9300....           STS     _A_UCSR0B, R16
     60          
     61            // инициализация Т/С0:
     62            TCCR0B = 0x00;                             // останов Т/С0
   \   0000008A   E000               LDI     R16, 0
   \   0000008C   BD05               OUT     0x25, R16
     63            TCNT0  = RELOAD_TIM0;                      // нач. знач-е
   \   0000008E   E908               LDI     R16, 152
   \   00000090   BD06               OUT     0x26, R16
     64            TCCR0A = 0x00;
   \   00000092   E000               LDI     R16, 0
   \   00000094   BD04               OUT     0x24, R16
     65            TCCR0B = START_TIM0;                       // таймер запускаем
   \   00000096   E004               LDI     R16, 4
   \   00000098   BD05               OUT     0x25, R16
     66            TIMSK0 = 0x01;                             // Т/С0 <- источник прерываний
   \   0000009A   E001               LDI     R16, 1
   \   0000009C   9300....           STS     _A_TIMSK0, R16
     67              
     68            SPI_MasterInit();                          // инициализация SPI в режиме Master
   \   000000A0   ....               RCALL   SPI_MasterInit
     69          //////////////////////////////////////////////////////////////////////////////////////////////////////////////
     70                    
     71                                             //Организация работы линии обмена                   
     72                    
     73          //////////////////////////////////////////////////////////////////////////////////////////////////////////////
     74          /*
     75            Перед началом передачи пакета данных всегда есть синхропауза (логическая 1). Это нужно для безошибочной работы
     76            по линии, т.к. система асинхронная и ведомое устройство может включиться не одновременно с ведущим устройством. 
     77            Даже если устройство включится уже после начала передачи ведущим, оно примет данные только после "полной" 
     78            синхропаузы, которую будет ожидать. Длина синхропаузы больше, чем длина одного слова данных.
     79            Применение асинхронной системы позволяет использовать простой канал связи, который гораздо дешевле, чем при 
     80            синхронной системе. 
     81          */    
     82            for (;;)
     83            {     
     84              UCSR0B &= ~(1<<RXEN0);                   // отключение приемника USART
   \                     ??main_0:
   \   000000A2   910000C1           LDS     R16, 193
   \   000000A6   7E0F               ANDI    R16, 0xEF
   \   000000A8   930000C1           STS     193, R16
     85              count_bod = CBOD;                        // счетчик БОД
   \   000000AC   E004               LDI     R16, 4
   \   000000AE   9300....           STS     count_bod, R16
     86          
     87              do
     88              {
     89                if (!(PINE & (1<<RX))) count_bod = CBOD;
   \                     ??main_1:
   \   000000B2   9960               SBIC    0x0C, 0x00
   \   000000B4   C003               RJMP    ??main_2
   \   000000B6   E004               LDI     R16, 4
   \   000000B8   9300....           STS     count_bod, R16
     90              } while (count_bod);                     // ожидание СИНХРО-ПАУЗЫ (всегда только перед командой)
   \                     ??main_2:
   \   000000BC   9100....           LDS     R16, count_bod
   \   000000C0   2300               TST     R16
   \   000000C2   F7B9               BRNE    ??main_1
     91          /*
     92              Выполнять присваивание count_bod = CBOD = 4, если RX = 0, пока count_bod - истина. Если же в течение четырёх
     93              периодов переполнения таймера0 с частотой 600 Гц, т.е. 6.7 мс, будет выполнено условие RX = 1, тогда
     94              программа уменьшит значение count_bod до нуля, условие while (count_bod) станет ложным и произойдёт 
     95              выход из цикла do/while. Только теперь устройство включится на приём. Таким образом, значение синхропаузы 
     96              составляет 6.7 мс. Начало приёма происходит при обнаружении старт-бита (логический 0).
     97          */    
     98              // приём данных по UART:
     99          /*
    100              Вперёд старший регистр. Вперёд старший байт.
    101          */
    102              UCSR0B |= (1<<RXEN0);                    // включение приемника USART
   \   000000C4   910000C1           LDS     R16, 193
   \   000000C8   6100               ORI     R16, 0x10
   \   000000CA   930000C1           STS     193, R16
    103               
    104              while (!(UCSR0A & (1<<RXC0)));           // ждем завершение приема байта
   \                     ??main_3:
   \   000000CE   9100....           LDS     R16, _A_UCSR0A
   \   000000D2   2F10               MOV     R17, R16
   \   000000D4   FF17               SBRS    R17, 7
   \   000000D6   CFFB               RJMP    ??main_3
    105              
    106              unsigned char var;                       // маркер передачи на синтезатор и фильтры или на || линии
    107              var=UDR0;                                // UDRn - USART I/O Data Register n
   \   000000D8   9100....           LDS     R16, _A_UDR0
   \   000000DC   2F80               MOV     R24, R16
    108              
    109              for(int i=27; i>=0; i--)                 // приём семи 4-х байтовых регистров по UART
   \   000000DE   E1AB               LDI     R26, 27
   \   000000E0   E0B0               LDI     R27, 0
   \                     ??main_4:
   \   000000E2   23BB               TST     R27
   \   000000E4   F06A               BRMI    ??main_5
    110              {
    111                while (!(UCSR0A & (1<<RXC0)));         // ждем завершение приема байта
   \                     ??main_6:
   \   000000E6   9100....           LDS     R16, _A_UCSR0A
   \   000000EA   2F10               MOV     R17, R16
   \   000000EC   FF17               SBRS    R17, 7
   \   000000EE   CFFB               RJMP    ??main_6
    112                R[i] = UDR0;                           // R6_4, R6_3,...,R6_1,...R0_1
   \   000000F0   9100....           LDS     R16, _A_UDR0
   \   000000F4   01FD               MOVW    R31:R30, R27:R26
   \   000000F6   ....               SUBI    R30, LOW((-(R) & 0xFFFF))
   \   000000F8   ....               SBCI    R31, (-(R) & 0xFFFF) >> 8
   \   000000FA   8300               ST      Z, R16
    113              }
   \   000000FC   9711               SBIW    R27:R26, 1
   \   000000FE   CFF1               RJMP    ??main_4
    114          
    115              if(var==0xAA)                            // если маркер передачи на синтезатор и фильтры
   \                     ??main_5:
   \   00000100   3A8A               CPI     R24, 170
   \   00000102   F009               BREQ    $+2+2
   \   00000104   C064               RJMP    ??main_7
    116              {
    117                
    118                t_led_on  = T_LED_ON;                  // время подсвечивания
   \   00000106   E302               LDI     R16, 50
   \   00000108   9300....           STS     t_led_on, R16
    119                LED_ON;   
   \   0000010C   98A5               CBI     0x14, 0x05
    120              
    121                unsigned char ONE, TWO;
    122                  
    123                // передача данных по SPI на hmc1044lp3 Tfcf:
    124          /*
    125                D8D7D6D5D4D3D2D1 D0A3A2A1A0CA2CA1CA0 - 2 байта для передачи по SPI на hmc1044lp3, где
    126                D8D7D6D5D4D3D2D1D0 - данные;
    127                A3A2A1A0 - адрес регистра = 01h;
    128                CA2CA1CA0 - адрес чипа = 110b.
    129          */
    130                ClearBit(PORTB, IN_SS0);               // деактивация ведомого ADF4350
   \   0000010E   9828               CBI     0x05, 0x00
    131                
    132                ONE = R[26];   // xxxx 1111 
   \   00000110   9100....           LDS     R16, (R + 26)
   \   00000114   2F90               MOV     R25, R16
    133                ONE>>=1;       // 0xxx x111
   \   00000116   9596               LSR     R25
    134                ONE&=0x7;      // 0000 0111 первый байт - данные без D0
   \   00000118   7097               ANDI    R25, 0x07
    135                
    136                TWO = R[26];   // xxxx 1111
   \   0000011A   9100....           LDS     R16, (R + 26)
   \   0000011E   2E60               MOV     R6, R16
    137                TWO&=0x1;      // 0000 0001   
   \   00000120   2D06               MOV     R16, R6
   \   00000122   FB00               BST     R16, 0
   \   00000124   2466               CLR     R6
   \   00000126   F860               BLD     R6, 0
    138                TWO<<=7;       // 1000 0000
   \   00000128   2D06               MOV     R16, R6
   \   0000012A   FB00               BST     R16, 0
   \   0000012C   2466               CLR     R6
   \   0000012E   F867               BLD     R6, 7
    139                TWO+=0x0E;     // 1000 1110 второй байт - D0, адреса регистра и чипа 
   \   00000130   E00E               LDI     R16, 14
   \   00000132   0E60               ADD     R6, R16
    140                
    141                ClearBit(PORTB, IN_SS1);               // активация ведомого hmc1044lp3 Tfcf
   \   00000134   982C               CBI     0x05, 0x04
    142                SPI_Write(ONE);                        // загрузка ONE по SPI
   \   00000136   2F09               MOV     R16, R25
   \   00000138   ....               RCALL   SPI_Write
    143                SPI_Write(TWO);                        // загрузка TWO по SPI 
   \   0000013A   2D06               MOV     R16, R6
   \   0000013C   ....               RCALL   SPI_Write
    144                SetBit(PORTB, IN_SS1);                 // деактивация ведомого hmc1044lp3 Tfcf
   \   0000013E   9A2C               SBI     0x05, 0x04
    145                
    146                SetBit(PORTB, IN_SS0);                 // активация ведомого ADF4350
   \   00000140   9A28               SBI     0x05, 0x00
    147           
    148                // передача данных по SPI на hmc1044lp3 Rfcf:
    149          /*
    150                D8D7D6D5D4D3D2D1 D0A3A2A1A0CA2CA1CA0 - 2 байта для передачи по SPI на hmc1044lp3, где
    151                D8D7D6D5D4D3D2D1D0 - данные;
    152                A3A2A1A0 - адрес регистра = 01h;
    153                CA2CA1CA0 - адрес чипа = 110b.
    154          */     
    155                ClearBit(PORTB, IN_SS0);               // деактивация ведомого ADF4350
   \   00000142   9828               CBI     0x05, 0x00
    156                
    157                ONE = R[27];   // xxxx 1111
   \   00000144   9100....           LDS     R16, (R + 27)
   \   00000148   2F90               MOV     R25, R16
    158                ONE>>=1;       // 0xxx x111
   \   0000014A   9596               LSR     R25
    159                ONE&=0x7;      // 0000 0111 первый байт - данные без D0
   \   0000014C   7097               ANDI    R25, 0x07
    160                
    161                TWO = R[27];   // xxxx 1111
   \   0000014E   9100....           LDS     R16, (R + 27)
   \   00000152   2E60               MOV     R6, R16
    162                TWO&=0x1;      // 0000 0001      
   \   00000154   2D06               MOV     R16, R6
   \   00000156   FB00               BST     R16, 0
   \   00000158   2466               CLR     R6
   \   0000015A   F860               BLD     R6, 0
    163                TWO<<=7;       // 1000 0000
   \   0000015C   2D06               MOV     R16, R6
   \   0000015E   FB00               BST     R16, 0
   \   00000160   2466               CLR     R6
   \   00000162   F867               BLD     R6, 7
    164                TWO+=0x0E;     // 1000 1110 второй байт - D0, адреса регистра и чипа
   \   00000164   E00E               LDI     R16, 14
   \   00000166   0E60               ADD     R6, R16
    165                
    166                ClearBit(PORTB, IN_SS2);               // активация ведомого hmc1044lp3 Rfcf
   \   00000168   982D               CBI     0x05, 0x05
    167                SPI_Write(ONE);                        // загрузка ONE по SPI
   \   0000016A   2F09               MOV     R16, R25
   \   0000016C   ....               RCALL   SPI_Write
    168                SPI_Write(TWO);                        // загрузка TWO по SPI 
   \   0000016E   2D06               MOV     R16, R6
   \   00000170   ....               RCALL   SPI_Write
    169                SetBit(PORTB, IN_SS2);                 // деактивация ведомого hmc1044lp3 Rfcf
   \   00000172   9A2D               SBI     0x05, 0x05
    170                
    171                SetBit(PORTB, IN_SS0);                 // активация ведомого ADF4350
   \   00000174   9A28               SBI     0x05, 0x00
    172               
    173                // передача данных по SPI на ADF4350:
    174                for(int j=0; j<=5; j++)
   \   00000176   2444               CLR     R4
   \   00000178   2455               CLR     R5
   \                     ??main_8:
   \   0000017A   E006               LDI     R16, 6
   \   0000017C   1640               CP      R4, R16
   \   0000017E   E000               LDI     R16, 0
   \   00000180   0650               CPC     R5, R16
   \   00000182   F00C               BRLT    $+2+2
   \   00000184   C0D2               RJMP    ??main_9
    175                {  
    176                  for(int i=(23-4*j); i>=(20-4*j); i--)  
   \   00000186   E127               LDI     R18, 23
   \   00000188   E030               LDI     R19, 0
   \   0000018A   0182               MOVW    R17:R16, R5:R4
   \   0000018C   0F00               LSL     R16
   \   0000018E   1F11               ROL     R17
   \   00000190   0F00               LSL     R16
   \   00000192   1F11               ROL     R17
   \   00000194   1B20               SUB     R18, R16
   \   00000196   0B31               SBC     R19, R17
   \   00000198   01D9               MOVW    R27:R26, R19:R18
   \                     ??main_10:
   \   0000019A   E124               LDI     R18, 20
   \   0000019C   E030               LDI     R19, 0
   \   0000019E   0182               MOVW    R17:R16, R5:R4
   \   000001A0   0F00               LSL     R16
   \   000001A2   1F11               ROL     R17
   \   000001A4   0F00               LSL     R16
   \   000001A6   1F11               ROL     R17
   \   000001A8   1B20               SUB     R18, R16
   \   000001AA   0B31               SBC     R19, R17
   \   000001AC   17A2               CP      R26, R18
   \   000001AE   07B3               CPC     R27, R19
   \   000001B0   F03C               BRLT    ??main_11
    177                  { 
    178                    SPI_Write(R[i]);                   // загрузка R5_4, R5_3,...,R5_1,...R0_1 по SPI в 32-разрядный буферный регистр
   \   000001B2   01FD               MOVW    R31:R30, R27:R26
   \   000001B4   ....               SUBI    R30, LOW((-(R) & 0xFFFF))
   \   000001B6   ....               SBCI    R31, (-(R) & 0xFFFF) >> 8
   \   000001B8   8100               LD      R16, Z
   \   000001BA   ....               RCALL   SPI_Write
    179                  }
   \   000001BC   9711               SBIW    R27:R26, 1
   \   000001BE   CFED               RJMP    ??main_10
    180                
    181                  SetBit(PORTB, IN_LE);                // загрузка данных, хранящихся в регистре сдвига, в один из регистров-защёлок
   \                     ??main_11:
   \   000001C0   9A2E               SBI     0x05, 0x06
    182                  ClearBit(PORTB, IN_LE);
   \   000001C2   982E               CBI     0x05, 0x06
    183                }
   \   000001C4   E001               LDI     R16, 1
   \   000001C6   0E40               ADD     R4, R16
   \   000001C8   E000               LDI     R16, 0
   \   000001CA   1E50               ADC     R5, R16
   \   000001CC   CFD6               RJMP    ??main_8
    184              }
    185              else
    186              if(var==0x55)                            // маркер передачи на || линии
   \                     ??main_7:
   \   000001CE   3585               CPI     R24, 85
   \   000001D0   F009               BREQ    $+2+2
   \   000001D2   C0AB               RJMP    ??main_9
    187              {  
    188                t_led_on  = (T_LED_ON/6);              // время подсвечивания
   \   000001D4   E008               LDI     R16, 8
   \   000001D6   9300....           STS     t_led_on, R16
    189                LED_ON; 
   \   000001DA   98A5               CBI     0x14, 0x05
    190          
    191                unsigned char temp;
    192                
    193                // передача данных в параллельный порт на ADL5240 Tаf:
    194                temp = R[25];  // xx1x xxxx
   \   000001DC   9100....           LDS     R16, (R + 25)
   \   000001E0   2F10               MOV     R17, R16
    195                temp>>=5;      // 0000 0xx1
   \   000001E2   9512               SWAP    R17
   \   000001E4   701F               ANDI    R17, 0x0F
   \   000001E6   9516               LSR     R17
    196                temp&=1;       // 0000 0001
   \   000001E8   2F01               MOV     R16, R17
   \   000001EA   2F10               MOV     R17, R16
   \   000001EC   7011               ANDI    R17, 0x01
    197                PORTE |= (temp<<ADLIN1_D1);
   \   000001EE   2F01               MOV     R16, R17
   \   000001F0   0F00               LSL     R16
   \   000001F2   0F00               LSL     R16
   \   000001F4   0F00               LSL     R16
   \   000001F6   B12E               IN      R18, 0x0E
   \   000001F8   2B20               OR      R18, R16
   \   000001FA   B92E               OUT     0x0E, R18
    198                
    199                temp = R[25];  // xxx1 xxxx
   \   000001FC   9100....           LDS     R16, (R + 25)
   \   00000200   2F10               MOV     R17, R16
    200                temp>>=4;      // 0000 xxx1
   \   00000202   9512               SWAP    R17
   \   00000204   701F               ANDI    R17, 0x0F
    201                temp&=1;       // 0000 0001
   \   00000206   2F01               MOV     R16, R17
   \   00000208   2F10               MOV     R17, R16
   \   0000020A   7011               ANDI    R17, 0x01
    202                PORTE |= (temp<<ADLIN1_D2);
   \   0000020C   2F01               MOV     R16, R17
   \   0000020E   9502               SWAP    R16
   \   00000210   7F00               ANDI    R16, 0xF0
   \   00000212   B12E               IN      R18, 0x0E
   \   00000214   2B20               OR      R18, R16
   \   00000216   B92E               OUT     0x0E, R18
    203                
    204                temp = R[25];  // xxxx 1xxx
   \   00000218   9100....           LDS     R16, (R + 25)
   \   0000021C   2F10               MOV     R17, R16
    205                temp>>=3;      // 000x xxx1
   \   0000021E   9516               LSR     R17
   \   00000220   9516               LSR     R17
   \   00000222   9516               LSR     R17
    206                temp&=1;       // 0000 0001
   \   00000224   2F01               MOV     R16, R17
   \   00000226   2F10               MOV     R17, R16
   \   00000228   7011               ANDI    R17, 0x01
    207                PORTE |= (temp<<ADLIN1_D3);      
   \   0000022A   2F01               MOV     R16, R17
   \   0000022C   9502               SWAP    R16
   \   0000022E   7F00               ANDI    R16, 0xF0
   \   00000230   0F00               LSL     R16
   \   00000232   B12E               IN      R18, 0x0E
   \   00000234   2B20               OR      R18, R16
   \   00000236   B92E               OUT     0x0E, R18
    208                
    209                temp = R[25];  // xxxx x1xx
   \   00000238   9100....           LDS     R16, (R + 25)
   \   0000023C   2F10               MOV     R17, R16
    210                temp>>=2;      // 00xx xxx1
   \   0000023E   9516               LSR     R17
   \   00000240   9516               LSR     R17
    211                temp&=1;       // 0000 0001
   \   00000242   2F01               MOV     R16, R17
   \   00000244   2F10               MOV     R17, R16
   \   00000246   7011               ANDI    R17, 0x01
    212                PORTE |= (temp<<ADLIN1_D4); 
   \   00000248   E400               LDI     R16, 64
   \   0000024A   9F10               MUL     R17, R16
   \   0000024C   B10E               IN      R16, 0x0E
   \   0000024E   2900               OR      R16, R0
   \   00000250   B90E               OUT     0x0E, R16
    213                
    214                temp = R[25];  // xxxx xx1x
   \   00000252   9100....           LDS     R16, (R + 25)
   \   00000256   2F10               MOV     R17, R16
    215                temp>>=1;      // 0xxx xxx1
   \   00000258   9516               LSR     R17
    216                temp&=1;       // 0000 0001
   \   0000025A   2F01               MOV     R16, R17
   \   0000025C   2F10               MOV     R17, R16
   \   0000025E   7011               ANDI    R17, 0x01
    217                PORTE |= (temp<<ADLIN1_D5);      
   \   00000260   2F01               MOV     R16, R17
   \   00000262   FB00               BST     R16, 0
   \   00000264   E000               LDI     R16, 0
   \   00000266   F907               BLD     R16, 7
   \   00000268   B12E               IN      R18, 0x0E
   \   0000026A   2B20               OR      R18, R16
   \   0000026C   B92E               OUT     0x0E, R18
    218                
    219                temp = R[25];  // xxxx xxx1
   \   0000026E   9100....           LDS     R16, (R + 25)
   \   00000272   2F10               MOV     R17, R16
    220                temp&=1;       // 0000 0001
   \   00000274   2F01               MOV     R16, R17
   \   00000276   2F10               MOV     R17, R16
   \   00000278   7011               ANDI    R17, 0x01
    221                PORTF |= (temp<<ADLIN1_D6);  
   \   0000027A   B301               IN      R16, 0x11
   \   0000027C   2B01               OR      R16, R17
   \   0000027E   BB01               OUT     0x11, R16
    222                
    223                // передача данных в параллельный порт на ADL5240 Rаf:
    224                temp = R[24];  // xx1x xxxx
   \   00000280   9100....           LDS     R16, (R + 24)
   \   00000284   2F10               MOV     R17, R16
    225                temp>>=5;      // 0000 0xx1
   \   00000286   9512               SWAP    R17
   \   00000288   701F               ANDI    R17, 0x0F
   \   0000028A   9516               LSR     R17
    226                temp&=1;       // 0000 0001
   \   0000028C   2F01               MOV     R16, R17
   \   0000028E   2F10               MOV     R17, R16
   \   00000290   7011               ANDI    R17, 0x01
    227                PORTF |= (temp<<ADLIN2_D1);
   \   00000292   2F01               MOV     R16, R17
   \   00000294   0F00               LSL     R16
   \   00000296   0F00               LSL     R16
   \   00000298   B321               IN      R18, 0x11
   \   0000029A   2B20               OR      R18, R16
   \   0000029C   BB21               OUT     0x11, R18
    228                
    229                temp = R[24];  // xxx1 xxxx
   \   0000029E   9100....           LDS     R16, (R + 24)
   \   000002A2   2F10               MOV     R17, R16
    230                temp>>=4;      // 0000 xxx1
   \   000002A4   9512               SWAP    R17
   \   000002A6   701F               ANDI    R17, 0x0F
    231                temp&=1;       // 0000 0001
   \   000002A8   2F01               MOV     R16, R17
   \   000002AA   2F10               MOV     R17, R16
   \   000002AC   7011               ANDI    R17, 0x01
    232                PORTF |= (temp<<ADLIN2_D2);
   \   000002AE   2F01               MOV     R16, R17
   \   000002B0   0F00               LSL     R16
   \   000002B2   0F00               LSL     R16
   \   000002B4   0F00               LSL     R16
   \   000002B6   B321               IN      R18, 0x11
   \   000002B8   2B20               OR      R18, R16
   \   000002BA   BB21               OUT     0x11, R18
    233                
    234                temp = R[24];  // xxxx 1xxx
   \   000002BC   9100....           LDS     R16, (R + 24)
   \   000002C0   2F10               MOV     R17, R16
    235                temp>>=3;      // 000x xxx1
   \   000002C2   9516               LSR     R17
   \   000002C4   9516               LSR     R17
   \   000002C6   9516               LSR     R17
    236                temp&=1;       // 0000 0001
   \   000002C8   2F01               MOV     R16, R17
   \   000002CA   2F10               MOV     R17, R16
   \   000002CC   7011               ANDI    R17, 0x01
    237                PORTF |= (temp<<ADLIN2_D3);      
   \   000002CE   2F01               MOV     R16, R17
   \   000002D0   9502               SWAP    R16
   \   000002D2   7F00               ANDI    R16, 0xF0
   \   000002D4   B321               IN      R18, 0x11
   \   000002D6   2B20               OR      R18, R16
   \   000002D8   BB21               OUT     0x11, R18
    238                
    239                temp = R[24];  // xxxx x1xx
   \   000002DA   9100....           LDS     R16, (R + 24)
   \   000002DE   2F10               MOV     R17, R16
    240                temp>>=2;      // 00xx xxx1
   \   000002E0   9516               LSR     R17
   \   000002E2   9516               LSR     R17
    241                temp&=1;       // 0000 0001
   \   000002E4   2F01               MOV     R16, R17
   \   000002E6   2F10               MOV     R17, R16
   \   000002E8   7011               ANDI    R17, 0x01
    242                PORTF |= (temp<<ADLIN2_D4); 
   \   000002EA   2F01               MOV     R16, R17
   \   000002EC   9502               SWAP    R16
   \   000002EE   7F00               ANDI    R16, 0xF0
   \   000002F0   0F00               LSL     R16
   \   000002F2   B321               IN      R18, 0x11
   \   000002F4   2B20               OR      R18, R16
   \   000002F6   BB21               OUT     0x11, R18
    243                
    244                temp = R[24];  // xxxx xx1x
   \   000002F8   9100....           LDS     R16, (R + 24)
   \   000002FC   2F10               MOV     R17, R16
    245                temp>>=1;      // 0xxx xxx1
   \   000002FE   9516               LSR     R17
    246                temp&=1;       // 0000 0001
   \   00000300   2F01               MOV     R16, R17
   \   00000302   2F10               MOV     R17, R16
   \   00000304   7011               ANDI    R17, 0x01
    247                PORTF |= (temp<<ADLIN2_D5);      
   \   00000306   E400               LDI     R16, 64
   \   00000308   9F10               MUL     R17, R16
   \   0000030A   B301               IN      R16, 0x11
   \   0000030C   2900               OR      R16, R0
   \   0000030E   BB01               OUT     0x11, R16
    248                
    249                temp = R[24];  // xxxx xxx1
   \   00000310   9100....           LDS     R16, (R + 24)
   \   00000314   2F10               MOV     R17, R16
    250                temp&=1;       // 0000 0001
   \   00000316   2F01               MOV     R16, R17
   \   00000318   2F10               MOV     R17, R16
   \   0000031A   7011               ANDI    R17, 0x01
    251                PORTF |= (temp<<ADLIN2_D6);      
   \   0000031C   2F01               MOV     R16, R17
   \   0000031E   FB00               BST     R16, 0
   \   00000320   E000               LDI     R16, 0
   \   00000322   F907               BLD     R16, 7
   \   00000324   B311               IN      R17, 0x11
   \   00000326   2B10               OR      R17, R16
   \   00000328   BB11               OUT     0x11, R17
    252              }    
    253              __watchdog_reset();
   \                     ??main_9:
   \   0000032A   95A8               WDR
   \   0000032C   CEBA               RJMP    ??main_0
   \   0000032E                      REQUIRE _A_DDRL
   \   0000032E                      REQUIRE _A_DDRK
   \   0000032E                      REQUIRE _A_DDRJ
   \   0000032E                      REQUIRE _A_DDRH
   \   0000032E                      REQUIRE _A_UDR0
   \   0000032E                      REQUIRE _A_UBRR0
   \   0000032E                      REQUIRE _A_UCSR0C
   \   0000032E                      REQUIRE _A_UCSR0B
   \   0000032E                      REQUIRE _A_UCSR0A
   \   0000032E                      REQUIRE _A_TIMSK0
   \   0000032E                      REQUIRE _A_WDTCSR
   \   0000032E                      REQUIRE _A_TCNT0
   \   0000032E                      REQUIRE _A_TCCR0B
   \   0000032E                      REQUIRE _A_TCCR0A
   \   0000032E                      REQUIRE _A_PORTG
   \   0000032E                      REQUIRE _A_DDRG
   \   0000032E                      REQUIRE _A_PORTF
   \   0000032E                      REQUIRE _A_DDRF
   \   0000032E                      REQUIRE _A_PORTE
   \   0000032E                      REQUIRE _A_DDRE
   \   0000032E                      REQUIRE _A_PINE
   \   0000032E                      REQUIRE _A_DDRD
   \   0000032E                      REQUIRE _A_DDRC
   \   0000032E                      REQUIRE _A_PORTB
   \   0000032E                      REQUIRE _A_DDRB
   \   0000032E                      REQUIRE _A_DDRA
    254            }
    255          }
    256          /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
    257          /*                                                                                                          */
    258          /*                                               Подпрограммы                                               */
    259          /*                                                                                                          */
    260          /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
    261          #pragma vector=TIMER0_OVF_vect         // директива определяет вектор функции прерывания, описание которой следует за ней                 

   \                                 In  segment CODE, align 2, keep-with-next
    262          __interrupt void timer0_ovf_isr(void)  // функция прерывания по переполнению таймера0 
   \                     timer0_ovf_isr:
    263          {
   \   00000000   932A               ST      -Y, R18
   \   00000002   931A               ST      -Y, R17
   \   00000004   930A               ST      -Y, R16
   \   00000006   B71F               IN      R17, 0x3F
   \   00000008   B72B               IN      R18, 0x3B
    264            //TIMER0 has overflowed
    265            TCNT0  = RELOAD_TIM0;                // reload counter value
   \   0000000A   E908               LDI     R16, 152
   \   0000000C   BD06               OUT     0x26, R16
    266          
    267            if (count_bod)  count_bod--;
   \   0000000E   9100....           LDS     R16, count_bod
   \   00000012   2300               TST     R16
   \   00000014   F029               BREQ    ??timer0_ovf_isr_0
   \   00000016   9100....           LDS     R16, count_bod
   \   0000001A   950A               DEC     R16
   \   0000001C   9300....           STS     count_bod, R16
    268          
    269            if(t_led_on)  t_led_on--;            // время подсвечивания --
   \                     ??timer0_ovf_isr_0:
   \   00000020   9100....           LDS     R16, t_led_on
   \   00000024   2300               TST     R16
   \   00000026   F031               BREQ    ??timer0_ovf_isr_1
   \   00000028   9100....           LDS     R16, t_led_on
   \   0000002C   950A               DEC     R16
   \   0000002E   9300....           STS     t_led_on, R16
   \   00000032   C001               RJMP    ??timer0_ovf_isr_2
    270            else          LED_OFF;               // LED-OFF
   \                     ??timer0_ovf_isr_1:
   \   00000034   9AA5               SBI     0x14, 0x05
    271          /*
    272            Частота переполнения таймера0 SYSTEM_TICK выбрана 600 Гц. Поэтому период переполнения таймера0 Tovf 
    273            составляет 1.7 мс, а константа перезагрузки 'TIM0' составляет RELOAD_TIM0 = 152(0x98). Подпрограмма 
    274            обработки прерывания по переполнению таймера0 вызывается каждые 1.7 мс, заново загружает константу 
    275            перезагрузки 'TIM0' и каждый раз уменьшает значение count_bod и t_led_on на единицу, пока значение 
    276            count_bod > 0 и t_led_on > 0. 
    277            Время горения светодиода будет T_LED_ON*Tovf = 120*1.7мс = 0.2c.
    278          */
    279          }
   \                     ??timer0_ovf_isr_2:
   \   00000036   BF2B               OUT     0x3B, R18
   \   00000038   BF1F               OUT     0x3F, R17
   \   0000003A   9109               LD      R16, Y+
   \   0000003C   9119               LD      R17, Y+
   \   0000003E   9129               LD      R18, Y+
   \   00000040   9518               RETI
   \   00000042                      REQUIRE _A_TCNT0
   \   00000042                      REQUIRE _A_PORTG
    280          
    281          // Подпрограмма инициализации SPI в режиме Master

   \                                 In  segment CODE, align 2, keep-with-next
    282          void SPI_MasterInit(void)
   \                     SPI_MasterInit:
    283          {
    284          /* 
    285            - Разрешение SPI в режиме мастера,
    286            - CPOL = 1 - генерируются тактовые импульсы отрицательной полярности,
    287            - CPHA = 0 - обработка данных производится по переднему спадающему фронту импульсов сигнала SCK,
    288            - установка скорости обмена fck/128 
    289          */
    290            SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0)|(1<<CPOL);
   \   00000000   E50B               LDI     R16, 91
   \   00000002   BD0C               OUT     0x2C, R16
    291          }
   \   00000004   9508               RET
   \   00000006                      REQUIRE _A_SPCR
    292          
    293          // Подпрограмма записи по SPI

   \                                 In  segment CODE, align 2, keep-with-next
    294          void SPI_Write(unsigned char dataout)
   \                     SPI_Write:
    295          {
    296            // Запись байта в регист данных ведущего (инициализация передачи)
    297            SPDR = dataout;
   \   00000000   BD0E               OUT     0x2E, R16
    298            // Ожидание завершения передачи (пока бит SPIF не установлен)
    299            while(!(SPSR & (1<<SPIF)));
   \                     ??SPI_Write_0:
   \   00000002   B51D               IN      R17, 0x2D
   \   00000004   2F21               MOV     R18, R17
   \   00000006   FF27               SBRS    R18, 7
   \   00000008   CFFC               RJMP    ??SPI_Write_0
    300          }
   \   0000000A   9508               RET
   \   0000000C                      REQUIRE _A_SPDR
   \   0000000C                      REQUIRE _A_SPSR

   \                                 In  segment INTVEC, offset 0x5c, root
   \                     `??timer0_ovf_isr??INTVEC 92`:
   \   0000005C   ........           JMP     timer0_ovf_isr

   Maximum stack usage in bytes:

     Function            CSTACK RSTACK
     --------            ------ ------
     SPI_MasterInit          0      2
     SPI_Write               0      2
     main                    7      2
       -> SPI_MasterInit     7      2
       -> SPI_Write          7      2
       -> SPI_Write          7      2
       -> SPI_Write          7      2
       -> SPI_Write          7      2
       -> SPI_Write          7      2
     timer0_ovf_isr          3      2


   Segment part sizes:

     Function/Label              Bytes
     --------------              -----
     Title                         51
     _A_DDRL                        1
     _A_DDRK                        1
     _A_DDRJ                        1
     _A_DDRH                        1
     _A_UDR0                        1
     _A_UBRR0                       2
     _A_UCSR0C                      1
     _A_UCSR0B                      1
     _A_UCSR0A                      1
     _A_TIMSK0                      1
     _A_WDTCSR                      1
     _A_SPDR                        1
     _A_SPSR                        1
     _A_SPCR                        1
     _A_TCNT0                       1
     _A_TCCR0B                      1
     _A_TCCR0A                      1
     _A_PORTG                       1
     _A_DDRG                        1
     _A_PORTF                       1
     _A_DDRF                        1
     _A_PORTE                       1
     _A_DDRE                        1
     _A_PINE                        1
     _A_DDRD                        1
     _A_DDRC                        1
     _A_PORTB                       1
     _A_DDRB                        1
     _A_DDRA                        1
     count                          1
     count_bod                      1
     t_led_on                       1
     R                             28
     Z                             28
     F                             28
     main                         814
     timer0_ovf_isr                66
     SPI_MasterInit                 6
     SPI_Write                     12
     ??timer0_ovf_isr??INTVEC 92    4
      Others                        7

 
  30 bytes in segment ABSOLUTE
 898 bytes in segment CODE
   7 bytes in segment INITTAB
   4 bytes in segment INTVEC
  51 bytes in segment NEAR_F
  87 bytes in segment NEAR_Z
 
 949 bytes of CODE memory (+ 11 bytes shared)
  87 bytes of DATA memory (+ 30 bytes shared)

Errors: none
Warnings: none
