###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.50.0.50277/W32 for Atmel AVR    13/Sep/2013  15:50:33 #
# Copyright (C) 1996-2010 IAR Systems AB.                                     #
#                                                                             #
#    Source file  =  d:\_IAR projects\ADF4350_IAR_ver.1\ADF4350_00\terminal.c #
#    Command line =  "d:\_IAR projects\ADF4350_IAR_ver.1\ADF4350_00\terminal. #
#                    c" --cpu=m1280 -ms -o "d:\_IAR                           #
#                    projects\ADF4350_IAR_ver.1\ADF4350_00\Project\ADF4350_Re #
#                    lease\Obj\" -D NDEBUG -lCN "d:\_IAR                      #
#                    projects\ADF4350_IAR_ver.1\ADF4350_00\Project\ADF4350_Re #
#                    lease\List\" -y --initializers_in_flash -s2 --no_cse     #
#                    --no_inline --no_code_motion --no_cross_call             #
#                    --no_clustering --no_tbaa -DENABLE_BIT_DEFINITIONS -e    #
#                    -I "E:\Program Files\IAR Systems\Embedded Workbench      #
#                    5.4\avr\INC\" -I "E:\Program Files\IAR Systems\Embedded  #
#                    Workbench 5.4\avr\INC\CLIB\" --eeprom_size 4096          #
#    List file    =  d:\_IAR projects\ADF4350_IAR_ver.1\ADF4350_00\Project\AD #
#                    F4350_Release\List\terminal.lst                          #
#    Object file  =  d:\_IAR projects\ADF4350_IAR_ver.1\ADF4350_00\Project\AD #
#                    F4350_Release\Obj\terminal.r90                           #
#                                                                             #
#                                                                             #
###############################################################################

d:\_IAR projects\ADF4350_IAR_ver.1\ADF4350_00\terminal.c
      1          #include "terminal.h"

   \                                 In  segment ABSOLUTE, at 0xc6
   \   <__C115> volatile __io _A_UDR0
   \                     _A_UDR0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc1
   \   <__C126> volatile __io _A_UCSR0B
   \                     _A_UCSR0B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc0
   \   <__C129> volatile __io _A_UCSR0A
   \                     _A_UCSR0A:
   \   00000000                      DS8 1
      2          
      3          /*************************************************************************
      4          Function: uart_putc()
      5          Purpose:  write byte to ringbuffer for transmitting via UART
      6          Input:    byte to be transmitted
      7          Returns:  none          
      8          **************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
      9          void uart_putc(unsigned char data)          // вывод байта в 'USART'
   \                     uart_putc:
     10           {  
     11          #ifdef DIR
     12             PORTB  |= (1<<DIR);                      // RS485 -> направление ПЕРЕДАЧА
     13          #endif
     14             UCSR0A |=  (1<<TXC0);
   \   00000000   911000C0           LDS     R17, 192
   \   00000004   6410               ORI     R17, 0x40
   \   00000006   931000C0           STS     192, R17
     15             UCSR0B &= ~(1<<TXB80);                   // 9-й бит -> '0'      (данные)
   \   0000000A   911000C1           LDS     R17, 193
   \   0000000E   7F1E               ANDI    R17, 0xFE
   \   00000010   931000C1           STS     193, R17
     16             UDR0 = data;                             // передать байт данных
   \   00000014   9300....           STS     _A_UDR0, R16
     17             while (!(UCSR0A & (1<<TXC0)));           // ждать конца передачи байта
   \                     ??uart_putc_0:
   \   00000018   9110....           LDS     R17, _A_UCSR0A
   \   0000001C   2F21               MOV     R18, R17
   \   0000001E   FF26               SBRS    R18, 6
   \   00000020   CFFB               RJMP    ??uart_putc_0
     18          #ifdef DIR
     19             PORTB &= ~(1<<DIR);                      // RS485 -> направление ПРИЕМ
     20          #endif
     21           } /* uart_putc */
   \   00000022   9508               RET
   \   00000024                      REQUIRE _A_UDR0
   \   00000024                      REQUIRE _A_UCSR0B
   \   00000024                      REQUIRE _A_UCSR0A
     22          
     23          /*************************************************************************
     24          Function: uart_puts()
     25          Purpose:  transmit string to UART
     26          Input:    string to be transmitted
     27          Returns:  none          
     28          **************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     29          void uart_puts(unsigned char *s )
   \                     uart_puts:
     30           { while (*s) 
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   01D8               MOVW    R27:R26, R17:R16
   \                     ??uart_puts_0:
   \   00000006   910C               LD      R16, X
   \   00000008   2300               TST     R16
   \   0000000A   F021               BREQ    ??uart_puts_1
     31                uart_putc(*s++);
   \   0000000C   910C               LD      R16, X
   \   0000000E   ....               RCALL   uart_putc
   \   00000010   9611               ADIW    R27:R26, 1
   \   00000012   CFF9               RJMP    ??uart_puts_0
     32           } /* uart_puts */
   \                     ??uart_puts_1:
   \   00000014   91A9               LD      R26, Y+
   \   00000016   91B9               LD      R27, Y+
   \   00000018   9508               RET
     33          
     34          /*************************************************************************
     35          Function: uart_puthex_byte()
     36          Purpose:  transmit upper and lower nibble as ASCII-hex to UART
     37          Input:    byte value
     38          Returns:  none
     39          This functions has been added by Martin Thomas <eversmith@heizung-thomas.de>
     40          Don't blame P. Fleury if it doesn't work ;-)
     41          **************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     42          void uart_puthex_byte(unsigned char  b)
   \                     uart_puthex_byte:
     43           { uart_puthex_nibble(b>>4);
   \   00000000   938A               ST      -Y, R24
   \   00000002   2F80               MOV     R24, R16
   \   00000004   2F08               MOV     R16, R24
   \   00000006   9502               SWAP    R16
   \   00000008   700F               ANDI    R16, 0x0F
   \   0000000A   ....               RCALL   uart_puthex_nibble
     44             uart_puthex_nibble(b);
   \   0000000C   2F08               MOV     R16, R24
   \   0000000E   ....               RCALL   uart_puthex_nibble
     45           } /* uart_puthex_byte */
   \   00000010   9189               LD      R24, Y+
   \   00000012   9508               RET
     46          
     47          /*************************************************************************
     48          Function: uart_puti()
     49          Purpose:  transmit integer as ASCII to UART
     50          Input:    integer value
     51          Returns:  none
     52          This functions has been added by Martin Thomas <eversmith@heizung-thomas.de>
     53          Don't blame P. Fleury if it doesn't work ;-)
     54          **************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     55          void uart_puti( signed int val )
   \                     uart_puti:
     56           { unsigned char buffer[8];
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   9728               SBIW    R29:R28, 8
   \   00000006   01C8               MOVW    R25:R24, R17:R16
     57            
     58             itoa(val, buffer);
   \   00000008   019E               MOVW    R19:R18, R29:R28
   \   0000000A   018C               MOVW    R17:R16, R25:R24
   \   0000000C   ....               RCALL   itoa
     59             uart_puts( buffer );
   \   0000000E   018E               MOVW    R17:R16, R29:R28
   \   00000010   ....               RCALL   uart_puts
     60           }/* uart_puti */
   \   00000012   9628               ADIW    R29:R28, 8
   \   00000014   9189               LD      R24, Y+
   \   00000016   9199               LD      R25, Y+
   \   00000018   9508               RET
     61          
     62          /*************************************************************************
     63          Function: uart_puthex_nibble()
     64          Purpose:  transmit lower nibble as ASCII-hex to UART
     65          Input:    byte value
     66          Returns:  none
     67          This functions has been added by Martin Thomas <eversmith@heizung-thomas.de>
     68          Don't blame P. Fleury if it doesn't work ;-)
     69          **************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     70          void uart_puthex_nibble(unsigned char b)
   \                     uart_puthex_nibble:
     71           { unsigned char  c = b & 0x0f;
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   2F90               MOV     R25, R16
   \   00000006   2F09               MOV     R16, R25
   \   00000008   700F               ANDI    R16, 0x0F
   \   0000000A   2F80               MOV     R24, R16
     72             if (c>9) c += 'A'-10;
   \   0000000C   308A               CPI     R24, 10
   \   0000000E   F010               BRCS    ??uart_puthex_nibble_0
   \   00000010   5C89               SUBI    R24, 201
   \   00000012   C001               RJMP    ??uart_puthex_nibble_1
     73             else c += '0';
   \                     ??uart_puthex_nibble_0:
   \   00000014   5D80               SUBI    R24, 208
     74             uart_putc(c);
   \                     ??uart_puthex_nibble_1:
   \   00000016   2F08               MOV     R16, R24
   \   00000018   ....               RCALL   uart_putc
     75           } /* uart_puthex_nibble */
   \   0000001A   9189               LD      R24, Y+
   \   0000001C   9199               LD      R25, Y+
   \   0000001E   9508               RET
     76          
     77          /*************************************************************************
     78           itoa:  конвертируем n в символы в s
     79          **************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     80          void itoa(signed int n, unsigned char s[])
   \                     itoa:
     81          {
   \   00000000   ........           CALL    ?PROLOGUE4_L09
   \   00000004   01D8               MOVW    R27:R26, R17:R16
   \   00000006   01C9               MOVW    R25:R24, R19:R18
     82             Bin_to_dec (s, n);
   \   00000008   019D               MOVW    R19:R18, R27:R26
   \   0000000A   018C               MOVW    R17:R16, R25:R24
   \   0000000C   ....               RCALL   Bin_to_dec
     83          }
   \   0000000E   E0E4               LDI     R30, 4
   \   00000010   ........           JMP     ?EPILOGUE_B4_L09
     84          
     85          /*----------------------------------------------------------------------------*/
     86          /* Функция:    Преобразование BIN->DEC 's[]'                                  */
     87          /* Принимает:  двоичное число                                                 */
     88          /* Возвращает: ничего (изменяет глобальные переменные)                        */
     89          /*----------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next
     90          void Bin_to_dec (unsigned char s[],     // буфер
   \                     Bin_to_dec:
     91                           signed int dnum)       // преобразуемое
     92          {              
   \   00000000   ........           CALL    ?PROLOGUE4_L09
   \   00000004   01D8               MOVW    R27:R26, R17:R16
   \   00000006   01C9               MOVW    R25:R24, R19:R18
     93             if(dnum < 0)                         // условие отрицательного числа
   \   00000008   2399               TST     R25
   \   0000000A   F432               BRPL    ??Bin_to_dec_0
     94             {
     95               dnum = -dnum;                      // берется модуль числа
   \   0000000C   9591               NEG     R25
   \   0000000E   9581               NEG     R24
   \   00000010   4090               SBCI    R25, 0
     96               s[0] = '-';                        // первый выводимый знак "-"
   \   00000012   E20D               LDI     R16, 45
   \   00000014   930C               ST      X, R16
   \   00000016   C002               RJMP    ??Bin_to_dec_1
     97             } 
     98             else s[0] = '+';                     // первый выводимый знак "+"
   \                     ??Bin_to_dec_0:
   \   00000018   E20B               LDI     R16, 43
   \   0000001A   930C               ST      X, R16
     99                                                  
    100             s[1] = dnum/1000 + '0';              // после знака выводится старший разряд четырехзначного числа
   \                     ??Bin_to_dec_1:
   \   0000001C   EE48               LDI     R20, 232
   \   0000001E   E053               LDI     R21, 3
   \   00000020   018C               MOVW    R17:R16, R25:R24
   \   00000022   ........           CALL    ?SS_DIVMOD_L02
   \   00000026   5D00               SUBI    R16, 208
   \   00000028   01FD               MOVW    R31:R30, R27:R26
   \   0000002A   8301               STD     Z+1, R16
    101             s[2] = (dnum%1000)/100 + '0';        // следующий разряд
   \   0000002C   EE48               LDI     R20, 232
   \   0000002E   E053               LDI     R21, 3
   \   00000030   018C               MOVW    R17:R16, R25:R24
   \   00000032   ........           CALL    ?SS_DIVMOD_L02
   \   00000036   018A               MOVW    R17:R16, R21:R20
   \   00000038   E644               LDI     R20, 100
   \   0000003A   E050               LDI     R21, 0
   \   0000003C   ........           CALL    ?SS_DIVMOD_L02
   \   00000040   5D00               SUBI    R16, 208
   \   00000042   01FD               MOVW    R31:R30, R27:R26
   \   00000044   8302               STD     Z+2, R16
    102             s[3] = ((dnum%1000)%100)/10 + '0';   // следующий разряд
   \   00000046   EE48               LDI     R20, 232
   \   00000048   E053               LDI     R21, 3
   \   0000004A   018C               MOVW    R17:R16, R25:R24
   \   0000004C   ........           CALL    ?SS_DIVMOD_L02
   \   00000050   018A               MOVW    R17:R16, R21:R20
   \   00000052   E644               LDI     R20, 100
   \   00000054   E050               LDI     R21, 0
   \   00000056   ........           CALL    ?SS_DIVMOD_L02
   \   0000005A   018A               MOVW    R17:R16, R21:R20
   \   0000005C   E04A               LDI     R20, 10
   \   0000005E   E050               LDI     R21, 0
   \   00000060   ........           CALL    ?SS_DIVMOD_L02
   \   00000064   5D00               SUBI    R16, 208
   \   00000066   01FD               MOVW    R31:R30, R27:R26
   \   00000068   8303               STD     Z+3, R16
    103             s[4] = dnum%10 + '0';                // младший разряд
   \   0000006A   E04A               LDI     R20, 10
   \   0000006C   E050               LDI     R21, 0
   \   0000006E   018C               MOVW    R17:R16, R25:R24
   \   00000070   ........           CALL    ?SS_DIVMOD_L02
   \   00000074   5D40               SUBI    R20, 208
   \   00000076   01FD               MOVW    R31:R30, R27:R26
   \   00000078   8344               STD     Z+4, R20
    104             s[5] = 0;                            // символ конца строки
   \   0000007A   E000               LDI     R16, 0
   \   0000007C   01FD               MOVW    R31:R30, R27:R26
   \   0000007E   8305               STD     Z+5, R16
    105          }  
   \   00000080   E0E4               LDI     R30, 4
   \   00000082   ........           JMP     ?EPILOGUE_B4_L09
    106          
    107          /*************************************************************************
    108          Function: uart_puts_p()
    109          Purpose:  transmit string from program memory to UART
    110          Input:    program memory string to be transmitted
    111          Returns:  none
    112          **************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    113          void uart_puts_p(unsigned char const __flash s[] )
   \                     uart_puts_p:
    114           { unsigned char c, i = 0; 
   \   00000000   ........           CALL    ?PROLOGUE5_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004   01C8               MOVW    R25:R24, R17:R16
   \   00000006   E0A0               LDI     R26, 0
    115             while ( (c = s[i++]) ) 
   \                     ??uart_puts_p_0:
   \   00000008   E0B0               LDI     R27, 0
   \   0000000A   01FC               MOVW    R31:R30, R25:R24
   \   0000000C   0FEA               ADD     R30, R26
   \   0000000E   1FFB               ADC     R31, R27
   \   00000010   9104               LPM     R16, Z
   \   00000012   95A3               INC     R26
   \   00000014   2E40               MOV     R4, R16
   \   00000016   2300               TST     R16
   \   00000018   F019               BREQ    ??uart_puts_p_1
    116                uart_putc(c);
   \   0000001A   2D04               MOV     R16, R4
   \   0000001C   ....               RCALL   uart_putc
   \   0000001E   CFF4               RJMP    ??uart_puts_p_0
    117           } /* uart_puts_p */
   \                     ??uart_puts_p_1:
   \   00000020   E0E5               LDI     R30, 5
   \   00000022   ........           JMP     ?EPILOGUE_B5_L09

   Maximum stack usage in bytes:

     Function                CSTACK RSTACK
     --------                ------ ------
     Bin_to_dec                  4      4
     itoa                        4      2
       -> Bin_to_dec             4      2
     uart_putc                   0      2
     uart_puthex_byte            1      2
       -> uart_puthex_nibble     1      2
       -> uart_puthex_nibble     1      2
     uart_puthex_nibble          2      2
       -> uart_putc              2      2
     uart_puti                  10      2
       -> itoa                  10      2
       -> uart_puts             10      2
     uart_puts                   2      2
       -> uart_putc              2      2
     uart_puts_p                 5      2
       -> uart_putc              5      2


   Segment part sizes:

     Function/Label     Bytes
     --------------     -----
     _A_UDR0               1
     _A_UCSR0B             1
     _A_UCSR0A             1
     uart_putc            36
     uart_puts            26
     uart_puthex_byte     20
     uart_puti            26
     uart_puthex_nibble   32
     itoa                 20
     Bin_to_dec          134
     uart_puts_p          38

 
   3 bytes in segment ABSOLUTE
 332 bytes in segment CODE
 
 332 bytes of CODE memory
   0 bytes of DATA memory (+ 3 bytes shared)

Errors: none
Warnings: none
