/************************************************************************************************************/
/*                                                                                                          */
/*                      Управляющая программа для ATmega1280 в проекте "Интерфейс ADF4350"                  */
/*                                       Версия 1.0 (2013.08.30_15-11)                                      */
/*                                                                                                          */
/************************************************************************************************************/
#include "main.h"
#include <math.h>
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
/*                                                                                                          */
/*                                        Главная функция программы                                         */
/*                                                                                                          */
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
int main( void )
{
  // задание интервала сброса WDT: 
  __watchdog_reset();                          // WDTCSR = WDIF WDIE WDP3 WDCE WDE WDP2 WDP1 WDP0 (XXXX XXXX)
  WDTCSR |= (1<<WDCE) | (1<<WDE);              // разрешение настройки/системного сброса WDT      (XXX1 1XXX)
  WDTCSR  = (1<<WDE)  | (1<<WDP3);             // установка тайм-аута = 512K циклов (~ 4.0 с)     (0010 1000)  
  
  DDRA = (1<<IN1_01)|(1<<IN1_02)|(1<<IN1_03)|(1<<IN1_04)|(1<<IN1_05)|(1<<IN1_06)|(1<<IN1_07)|(1<<IN1_08); // выходы
  
  DDRB = (1<<IN_SS0)|(1<<IN_SCK)|(1<<IN_MOSI)|(1<<IN_SS1)|(1<<IN_SS2)|(1<<IN_LE); // выходы
  
  DDRC = (1<<IN1_09)|(1<<IN1_10)|(1<<IN1_11)|(1<<IN1_12)|(1<<IN1_13)|(1<<IN1_14)|(1<<IN1_15)|(1<<IN1_16); // выходы

  DDRD = (1<<IN2_01)|(1<<IN2_02)|(1<<IN2_03)|(1<<IN2_04)|(1<<IN2_05)|(1<<IN2_06)|(1<<IN2_07)|(1<<IN2_08); // выходы

  PORTE = (1<<RX)|(1<<TX); // подтяжка на питание или 1 на выходе
  DDRE = (1<<TX)|(1<<ADLIN1_D0)|(1<<ADLIN1_D1)|(1<<ADLIN1_D2)|(1<<ADLIN1_D3)|(1<<ADLIN1_D4)|(1<<ADLIN1_D5); // выходы

  DDRF = (1<<ADLIN1_D6)|(1<<ADLIN2_D0)|(1<<ADLIN2_D1)|(1<<ADLIN2_D2)|(1<<ADLIN2_D3)|(1<<ADLIN2_D4)|(1<<ADLIN2_D5)|(1<<ADLIN2_D6); // выходы
  
  PORTG = (1<<LED); // 1 на выходе
  DDRG = (1<<IN4_09)|(1<<IN4_10)|(1<<IN4_11)|(1<<IN4_12)|(1<<IN4_13)|(1<<LED); // выходы
  
  DDRH = (1<<IN2_09)|(1<<IN2_10)|(1<<IN2_11)|(1<<IN2_12)|(1<<IN2_13)|(1<<IN2_14)|(1<<IN2_15)|(1<<IN2_16); // выходы
  
  DDRJ = (1<<IN3_01)|(1<<IN3_02)|(1<<IN3_03)|(1<<IN3_04)|(1<<IN3_05)|(1<<IN3_06)|(1<<IN3_07)|(1<<IN3_08); // выходы

  DDRK = (1<<IN3_09)|(1<<IN3_10)|(1<<IN3_11)|(1<<IN3_12)|(1<<IN3_13)|(1<<IN3_14); // выходы

  DDRL = (1<<IN4_01)|(1<<IN4_02)|(1<<IN4_03)|(1<<IN4_04)|(1<<IN4_05)|(1<<IN4_06)|(1<<IN4_07)|(1<<IN4_08); // выходы

  if (PINB & (1<<DEBUG)) mode = 1; else mode = 0; // выбор режима работы устройства
  
  count_bod = 1;                                  // минимум 1 прерывание
  t_led_on  = 0;                                  // время индикации
  
  __watchdog_reset();                             // 1-й "простой" cброс сторожевого таймера
  __enable_interrupt();                           // прерывания разрешаем
  
//////////////////////////////////////////Режим отладки/////////////////////////////////////////////////////// 
  if(!mode)
  {
    // инициализация USART (2400):
    UCSR0A = 0x00;                             // запрет настроек USART на время установки скорости передачи
    UCSR0B = 0x00;                             
    UCSR0C = 0x06;                             // размер слова данных 8 бит
    UBRR0L = UBBR_2K4L;                        // задание скорости 2400
    UBRR0H = UBBR_2K4L;   
    UCSR0B = 0x0C;                             // разрешение передачи (TXENn = 1); 9-Bit

    // инициализация Т/С0:
    TCCR0B = 0x00;                             // останов Т/С0
    TCNT0  = RELOAD_TIM0;                      // нач. знач-е
    TCCR0A = 0x00;
    TCCR0B = START_TIM0;                       // таймер запускаем
    TIMSK0 = 0x01;                             // Т/С0 <- источник прерываний
    
    SPI_MasterInit();                          // инициализация SPI в режиме Master
   
    // вывод строки из ПЗУ, uart_putc(0x0a); - перевод на след. строку  
    uart_puts_p(Title);                                 uart_putc(0x0d); uart_putc(0x0a);                        
    uart_puts("------------------------------------");  uart_putc(0x0d); uart_putc(0x0a);
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
          
                                   //Организация работы линии обмена                   
          
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
    Организация работы линии обмена.
    В системе может быть несколько ведомых устройств. Поэтому чтобы не было коллизий, когда устройства 
    одновременно посылают информацию в линию обмена, организована работа по принципу запрос - ответ.
    Команда запроса в общей сложности занимает одно 11-битное слово. Первый бит слова - старт-бит, всегда является
    нулем. Старт-бит может быть только один. Затем идут 9 информационных бит (9-битовая передача информации), 
    начиная с младшего. Если старший бит является единицей, то передается команда (запрос), если же нуль - данные
    (ответ). Скорость обмена по линии составляет 2400 бит/с. Она сложилась исторически и связана с процессом работы
    информационной техники предыдущих поколений. Затем идет один стоп-бит. Вообще их может быть 1 или 2. Если 
    стоп-битов 2, то будет более точная проверка передачи слова, но более медленная скорость обработки. 
    Перед командой запроса всегда есть синхропауза (логическая 1), которая свидетельствует о том, что по линии 
    передается команда, а не данные. Это нужно для безошибочной работы по линии, т.к. система асинхронная и ведомое
    устройство может включиться не одновременно с ведущим устройством. Даже если устройство включится уже после 
    начала передачи ведущим команды, оно примет команду только после "полной" синхропаузы, которую будет ожидать в
    течение определённого протоколом обмена времени. Синхропауза всегда немного длиннее, чем 11-битное слово.
    Применение асинхронной системы позволяет использовать простой канал связи, который гораздо дешевле, чем при 
    синхронной системе. 
*/    
    for (;;)
    {  
      UCSR0B &= ~(1<<RXEN0);                   // отключение приемника USART
      count_bod = CBOD;                        // счетчик БОД

      do
      {
        if (!(PIND & (1<<RX))) count_bod = CBOD;
      } while (count_bod);                     // ожидание СИНХРО-ПАУЗЫ (всегда только перед командой)
/*
      Выполнять присваивание count_bod = CBOD = 4, если RX = 0, пока count_bod - истина. Если же в течение четырёх
      периодов переполнения таймера0 с частотой 600 Гц, т.е. 6.7 мс, будет выполнено условие RX = 1, тогда
      программа уменьшит значение count_bod до нуля, условие while (count_bod) станет ложным и произойдёт 
      выход из цикла do/while. Только теперь устройство включится на приём. Таким образом, значение синхропаузы 
      составляет 6.7 мс.
*/        
      UCSR0B |= (1<<RXEN0);                    // включение приемника USART

      while (!(UCSR0A & (1<<RXC0)));           // ждем завершение приема байта 

      if (UCSR0B & (1<<RXB80))                 // если 9-й бит =1, то принята команда
      {
        unsigned char var;
        var  = UDR0;                           // UDRn - USART I/O Data Register n
        var &= 0x0f;                           // адрес датчика д/б не более 15
        if (var == ADF4350)                    // обратились к этому устройству?
        { 
          uart_putc(ADF4350);                  // ответ ведущему о готовности принять данные
        }    
   }
  }
 }
  return 0;
}
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
/*                                                                                                          */
/*                                               Подпрограммы                                               */
/*                                                                                                          */
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
#pragma vector=TIMER0_OVF_vect         // директива определяет вектор функции прерывания, описание которой следует за ней                 
__interrupt void timer0_ovf_isr(void)  // функция прерывания по переполнению таймера0 
{
  //TIMER0 has overflowed
  TCNT0  = RELOAD_TIM0;                // reload counter value

  if (count_bod)  count_bod--;

  if(t_led_on)  t_led_on--;            // время подсвечивания --
  else          LED_OFF;               // LED-OFF
/*
  Частота переполнения таймера0 SYSTEM_TICK выбрана 600 Гц. Поэтому период переполнения таймера0 Tovf 
  составляет 1.7 мс, а константа перезагрузки 'TIM0' составляет RELOAD_TIM0 = 152(0x98). Подпрограмма 
  обработки прерывания по переполнению таймера0 вызывается каждые 1.7 мс, заново загружает константу 
  перезагрузки 'TIM0' и каждый раз уменьшает значение count_bod и t_led_on на единицу, пока значение 
  count_bod > 0 и t_led_on > 0. 
  Время горения светодиода будет T_LED_ON*Tovf = 120*1.7мс = 0.2c.
*/
}

// Подпрограмма инициализации SPI в режиме Master
void SPI_MasterInit(void)
{
/* 
  - Разрешение SPI в режиме мастера,
  - CPOL = 0 - генерируются тактовые импульсы положительной полярности,
  - CPHA = 0 - обработка данных производится по переднему фронту импульсов сигнала SCK,
  - установка скорости обмена fck/128 
*/
  SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0);
}

// Подпрограмма записи/чтения через SPI
unsigned char SPI_WriteRead(unsigned char dataout)
{
  // Запись байта в регист данных ведущего (инициализация передачи)
  SPDR = dataout;
  // Ожидание завершения передачи (пока бит SPIF не установлен)
  while(!(SPSR & (1<<SPIF)));
  // Чтение принятых данных и выход из процедуры
  return SPDR;
}