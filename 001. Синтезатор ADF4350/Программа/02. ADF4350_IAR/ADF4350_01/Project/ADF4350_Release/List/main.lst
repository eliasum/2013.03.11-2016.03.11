###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.50.0.50277/W32 for Atmel AVR    19/Oct/2013  11:34:32 #
# Copyright (C) 1996-2010 IAR Systems AB.                                     #
#                                                                             #
#    Source file  =  D:\_IAR projects\ADF4350_IAR_ver.1\ADF4350_01\main.c     #
#    Command line =  "D:\_IAR projects\ADF4350_IAR_ver.1\ADF4350_01\main.c"   #
#                    --cpu=m1280 -ms -o "D:\_IAR                              #
#                    projects\ADF4350_IAR_ver.1\ADF4350_01\Project\ADF4350_Re #
#                    lease\Obj\" -D NDEBUG -lCN "D:\_IAR                      #
#                    projects\ADF4350_IAR_ver.1\ADF4350_01\Project\ADF4350_Re #
#                    lease\List\" -y --initializers_in_flash -s2 --no_cse     #
#                    --no_inline --no_code_motion --no_cross_call             #
#                    --no_clustering --no_tbaa -DENABLE_BIT_DEFINITIONS -e    #
#                    -I "E:\Program Files\IAR Systems\Embedded Workbench      #
#                    5.4\avr\INC\" -I "E:\Program Files\IAR Systems\Embedded  #
#                    Workbench 5.4\avr\INC\CLIB\" --eeprom_size 4096          #
#    List file    =  D:\_IAR projects\ADF4350_IAR_ver.1\ADF4350_01\Project\AD #
#                    F4350_Release\List\main.lst                              #
#    Object file  =  D:\_IAR projects\ADF4350_IAR_ver.1\ADF4350_01\Project\AD #
#                    F4350_Release\Obj\main.r90                               #
#                                                                             #
#                                                                             #
###############################################################################

D:\_IAR projects\ADF4350_IAR_ver.1\ADF4350_01\main.c
      1          /************************************************************************************************************/
      2          /*                                                                                                          */
      3          /*                      Управляющая программа для ATmega1280 в проекте "Интерфейс ADF4350"                  */
      4          /*                                       Версия 1.1 (2013.09.24_15-51)                                      */
      5          /*                                                                                                          */
      6          /************************************************************************************************************/
      7          #include "main.h"

   \                                 In  segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash Title[51]
   \                     Title:
   \   00000000   444134463533       DC8 41H, 44H, 46H, 34H, 33H, 35H, 30H, 20H
   \              2030        
   \   00000008   202D69576564       DC8 2DH, 20H, 57H, 69H, 64H, 65H, 62H, 61H
   \              6162        
   \   00000010   646E53206E79       DC8 6EH, 64H, 20H, 53H, 79H, 6EH, 74H, 68H
   \              6874        
   \   00000018   73657A697265       DC8 65H, 73H, 69H, 7AH, 65H, 72H, 20H, 77H
   \              7720        
   \   00000020   746920686E49       DC8 69H, 74H, 68H, 20H, 49H, 6EH, 74H, 65H
   \              6574        
   \   00000028   726774616465       DC8 67H, 72H, 61H, 74H, 65H, 64H, 20H, 56H
   \              5620        
   \   00000030   4F4300             DC8 43H, 4FH, 0

   \                                 In  segment ABSOLUTE, at 0x10a
   \   <__C51> volatile __ext_io _A_DDRL
   \                     _A_DDRL:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x107
   \   <__C60> volatile __ext_io _A_DDRK
   \                     _A_DDRK:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x104
   \   <__C69> volatile __ext_io _A_DDRJ
   \                     _A_DDRJ:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x101
   \   <__C78> volatile __ext_io _A_DDRH
   \                     _A_DDRH:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc6
   \   <__C115> volatile __io _A_UDR0
   \                     _A_UDR0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc4
   \   <__C119> volatile __io _A_UBRR0
   \                     _A_UBRR0:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0xc2
   \   <__C123> volatile __io _A_UCSR0C
   \                     _A_UCSR0C:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc1
   \   <__C126> volatile __io _A_UCSR0B
   \                     _A_UCSR0B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc0
   \   <__C129> volatile __io _A_UCSR0A
   \                     _A_UCSR0A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x6e
   \   <__C293> volatile __io _A_TIMSK0
   \                     _A_TIMSK0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x60
   \   <__C325> volatile __io _A_WDTCSR
   \                     _A_WDTCSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x4e
   \   <__C359> volatile __io _A_SPDR
   \                     _A_SPDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x4d
   \   <__C362> volatile __io _A_SPSR
   \                     _A_SPSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x4c
   \   <__C365> volatile __io _A_SPCR
   \                     _A_SPCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x46
   \   <__C375> volatile __io _A_TCNT0
   \                     _A_TCNT0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x45
   \   <__C378> volatile __io _A_TCCR0B
   \                     _A_TCCR0B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x44
   \   <__C381> volatile __io _A_TCCR0A
   \                     _A_TCCR0A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x34
   \   <__C425> volatile __io _A_PORTG
   \                     _A_PORTG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x33
   \   <__C428> volatile __io _A_DDRG
   \                     _A_DDRG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x31
   \   <__C434> volatile __io _A_PORTF
   \                     _A_PORTF:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x30
   \   <__C437> volatile __io _A_DDRF
   \                     _A_DDRF:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2e
   \   <__C443> volatile __io _A_PORTE
   \                     _A_PORTE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2d
   \   <__C446> volatile __io _A_DDRE
   \                     _A_DDRE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2a
   \   <__C455> volatile __io _A_DDRD
   \                     _A_DDRD:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x29
   \   <__C458> volatile __io _A_PIND
   \                     _A_PIND:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x27
   \   <__C464> volatile __io _A_DDRC
   \                     _A_DDRC:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x25
   \   <__C470> volatile __io _A_PORTB
   \                     _A_PORTB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x24
   \   <__C473> volatile __io _A_DDRB
   \                     _A_DDRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x23
   \   <__C476> volatile __io _A_PINB
   \                     _A_PINB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x21
   \   <__C482> volatile __io _A_DDRA
   \                     _A_DDRA:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char mode
   \                     mode:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char volatile count_bod
   \                     count_bod:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char volatile t_led_on
   \                     t_led_on:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char R[28]
   \                     R:
   \   00000000                      DS8 28
      8          #include <math.h>     
      9          /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
     10          /*                                                                                                          */
     11          /*                                        Главная функция программы                                         */
     12          /*                                                                                                          */
     13          /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

   \                                 In  segment CODE, align 2, keep-with-next
     14          int main( void )
   \                     main:
     15          {
   \   00000000   ........           CALL    ?PROLOGUE8_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
     16            // задание интервала сброса WDT: 
     17            __watchdog_reset();                          // WDTCSR = WDIF WDIE WDP3 WDCE WDE WDP2 WDP1 WDP0 (XXXX XXXX)
   \   00000004   95A8               WDR
     18            WDTCSR |= (1<<WDCE) | (1<<WDE);              // разрешение настройки/системного сброса WDT      (XXX1 1XXX)
   \   00000006   9100....           LDS     R16, _A_WDTCSR
   \   0000000A   6108               ORI     R16, 0x18
   \   0000000C   9300....           STS     _A_WDTCSR, R16
     19            WDTCSR  = (1<<WDE)  | (1<<WDP3);             // установка тайм-аута = 512K циклов (~ 4.0 с)     (0010 1000)  
   \   00000010   E208               LDI     R16, 40
   \   00000012   9300....           STS     _A_WDTCSR, R16
     20            
     21            // инициализация портов:
     22            DDRA = (1<<IN1_01)|(1<<IN1_02)|(1<<IN1_03)|(1<<IN1_04)|(1<<IN1_05)|(1<<IN1_06)|(1<<IN1_07)|(1<<IN1_08); // выходы
   \   00000016   EF0F               LDI     R16, 255
   \   00000018   B901               OUT     0x01, R16
     23            
     24            PORTB = (1<<IN_SS0)|(1<<IN_SS1)|(1<<IN_SS2); // 1 на выходе
   \   0000001A   E301               LDI     R16, 49
   \   0000001C   B905               OUT     0x05, R16
     25            DDRB = (1<<IN_SS0)|(1<<IN_SCK)|(1<<IN_MOSI)|(1<<IN_SS1)|(1<<IN_SS2)|(1<<IN_LE); // выходы
   \   0000001E   E707               LDI     R16, 119
   \   00000020   B904               OUT     0x04, R16
     26            
     27            DDRC = (1<<IN1_09)|(1<<IN1_10)|(1<<IN1_11)|(1<<IN1_12)|(1<<IN1_13)|(1<<IN1_14)|(1<<IN1_15)|(1<<IN1_16); // выходы
   \   00000022   EF0F               LDI     R16, 255
   \   00000024   B907               OUT     0x07, R16
     28          
     29            DDRD = (1<<IN2_01)|(1<<IN2_02)|(1<<IN2_03)|(1<<IN2_04)|(1<<IN2_05)|(1<<IN2_06)|(1<<IN2_07)|(1<<IN2_08); // выходы
   \   00000026   EF0F               LDI     R16, 255
   \   00000028   B90A               OUT     0x0A, R16
     30          
     31            PORTE = (1<<RX)|(1<<TX); // подтяжка на питание или 1 на выходе
   \   0000002A   E003               LDI     R16, 3
   \   0000002C   B90E               OUT     0x0E, R16
     32            DDRE = (1<<TX)|(1<<ADLIN1_D0)|(1<<ADLIN1_D1)|(1<<ADLIN1_D2)|(1<<ADLIN1_D3)|(1<<ADLIN1_D4)|(1<<ADLIN1_D5); // выходы
   \   0000002E   EF0E               LDI     R16, 254
   \   00000030   B90D               OUT     0x0D, R16
     33          
     34            DDRF = (1<<ADLIN1_D6)|(1<<ADLIN2_D0)|(1<<ADLIN2_D1)|(1<<ADLIN2_D2)|(1<<ADLIN2_D3)|(1<<ADLIN2_D4)|(1<<ADLIN2_D5)|(1<<ADLIN2_D6); // выходы
   \   00000032   EF0F               LDI     R16, 255
   \   00000034   BB00               OUT     0x10, R16
     35            
     36            PORTG = (1<<LED); // 1 на выходе
   \   00000036   E200               LDI     R16, 32
   \   00000038   BB04               OUT     0x14, R16
     37            DDRG = (1<<IN4_09)|(1<<IN4_10)|(1<<IN4_11)|(1<<IN4_12)|(1<<IN4_13)|(1<<LED); // выходы
   \   0000003A   E30F               LDI     R16, 63
   \   0000003C   BB03               OUT     0x13, R16
     38            
     39            DDRH = (1<<IN2_09)|(1<<IN2_10)|(1<<IN2_11)|(1<<IN2_12)|(1<<IN2_13)|(1<<IN2_14)|(1<<IN2_15)|(1<<IN2_16); // выходы
   \   0000003E   EF0F               LDI     R16, 255
   \   00000040   9300....           STS     _A_DDRH, R16
     40            
     41            DDRJ = (1<<IN3_01)|(1<<IN3_02)|(1<<IN3_03)|(1<<IN3_04)|(1<<IN3_05)|(1<<IN3_06)|(1<<IN3_07)|(1<<IN3_08); // выходы
   \   00000044   EF0F               LDI     R16, 255
   \   00000046   9300....           STS     _A_DDRJ, R16
     42          
     43            DDRK = (1<<IN3_09)|(1<<IN3_10)|(1<<IN3_11)|(1<<IN3_12)|(1<<IN3_13)|(1<<IN3_14)|(1<<IN3_15)|(1<<IN3_16); // выходы
   \   0000004A   EF0F               LDI     R16, 255
   \   0000004C   9300....           STS     _A_DDRK, R16
     44          
     45            DDRL = (1<<IN4_01)|(1<<IN4_02)|(1<<IN4_03)|(1<<IN4_04)|(1<<IN4_05)|(1<<IN4_06)|(1<<IN4_07)|(1<<IN4_08); // выходы
   \   00000050   EF0F               LDI     R16, 255
   \   00000052   9300....           STS     _A_DDRL, R16
     46          
     47            if (PINB & (1<<DEBUG)) mode = 1; else mode = 0; // выбор режима работы устройства
   \   00000056   9B1F               SBIS    0x03, 0x07
   \   00000058   C004               RJMP    ??main_0
   \   0000005A   E001               LDI     R16, 1
   \   0000005C   9300....           STS     mode, R16
   \   00000060   C003               RJMP    ??main_1
   \                     ??main_0:
   \   00000062   E000               LDI     R16, 0
   \   00000064   9300....           STS     mode, R16
     48            
     49            count_bod = 1;                                  // минимум 1 прерывание
   \                     ??main_1:
   \   00000068   E001               LDI     R16, 1
   \   0000006A   9300....           STS     count_bod, R16
     50            t_led_on  = 0;                                  // время индикации
   \   0000006E   E000               LDI     R16, 0
   \   00000070   9300....           STS     t_led_on, R16
     51            
     52            __watchdog_reset();                             // 1-й "простой" cброс сторожевого таймера
   \   00000074   95A8               WDR
     53            __enable_interrupt();                           // прерывания разрешаем
   \   00000076   9478               SEI
     54            
     55          //////////////////////////////////////////Режим отладки/////////////////////////////////////////////////////// 
     56            if(mode)
   \   00000078   9100....           LDS     R16, mode
   \   0000007C   2300               TST     R16
   \   0000007E   F409               BRNE    $+2+2
   \   00000080   C10F               RJMP    ??main_2
     57            {
     58              // инициализация USART (2400):
     59              UCSR0A = 0x00;                             // запрет настроек USART на время установки скорости передачи
   \   00000082   E000               LDI     R16, 0
   \   00000084   9300....           STS     _A_UCSR0A, R16
     60              UCSR0B = 0x00;                             
   \   00000088   E000               LDI     R16, 0
   \   0000008A   9300....           STS     _A_UCSR0B, R16
     61              UCSR0C = 0x06;                             // размер слова данных 8 бит
   \   0000008E   E006               LDI     R16, 6
   \   00000090   9300....           STS     _A_UCSR0C, R16
     62              UBRR0L = UBBR_2K4L;                        // задание скорости 2400
   \   00000094   E10F               LDI     R16, 31
   \   00000096   9300....           STS     _A_UBRR0, R16
     63              UBRR0H = UBBR_2K4L;   
   \   0000009A   E10F               LDI     R16, 31
   \   0000009C   930000C5           STS     197, R16
     64              UCSR0B = 0x0C;                             // разрешение передачи (TXENn = 1); 9-Bit
   \   000000A0   E00C               LDI     R16, 12
   \   000000A2   9300....           STS     _A_UCSR0B, R16
     65          
     66              // инициализация Т/С0:
     67              TCCR0B = 0x00;                             // останов Т/С0
   \   000000A6   E000               LDI     R16, 0
   \   000000A8   BD05               OUT     0x25, R16
     68              TCNT0  = RELOAD_TIM0;                      // нач. знач-е
   \   000000AA   EB08               LDI     R16, 184
   \   000000AC   BD06               OUT     0x26, R16
     69              TCCR0A = 0x00;
   \   000000AE   E000               LDI     R16, 0
   \   000000B0   BD04               OUT     0x24, R16
     70              TCCR0B = START_TIM0;                       // таймер запускаем
   \   000000B2   E004               LDI     R16, 4
   \   000000B4   BD05               OUT     0x25, R16
     71              TIMSK0 = 0x01;                             // Т/С0 <- источник прерываний
   \   000000B6   E001               LDI     R16, 1
   \   000000B8   9300....           STS     _A_TIMSK0, R16
     72              
     73              SPI_MasterInit();                          // инициализация SPI в режиме Master
   \   000000BC   ....               RCALL   SPI_MasterInit
     74             
     75              // вывод строки из ПЗУ, uart_putc(0x0a); - перевод на след. строку  
     76              uart_puts_p(Title);                                 uart_putc(0x0d); uart_putc(0x0a);                        
   \   000000BE   ....               LDI     R16, LOW(Title)
   \   000000C0   ....               LDI     R17, (Title) >> 8
   \   000000C2   ........           CALL    uart_puts_p
   \   000000C6   E00D               LDI     R16, 13
   \   000000C8   ........           CALL    uart_putc
   \   000000CC   E00A               LDI     R16, 10
   \   000000CE   ........           CALL    uart_putc
     77              uart_puts("------------------------------------");  uart_putc(0x0d); uart_putc(0x0a);
   \   000000D2   ....               LDI     R16, LOW(`?<Constant "---------------------...">`)
   \   000000D4   ....               LDI     R17, (`?<Constant "---------------------...">`) >> 8
   \   000000D6   ........           CALL    uart_puts
   \   000000DA   E00D               LDI     R16, 13
   \   000000DC   ........           CALL    uart_putc
   \   000000E0   E00A               LDI     R16, 10
   \   000000E2   ........           CALL    uart_putc
     78          //////////////////////////////////////////////////////////////////////////////////////////////////////////////
     79                    
     80                                             //Организация работы линии обмена                   
     81                    
     82          //////////////////////////////////////////////////////////////////////////////////////////////////////////////
     83          /*
     84              Организация работы линии обмена.
     85              В системе может быть несколько ведомых устройств. Поэтому чтобы не было коллизий, когда устройства 
     86              одновременно посылают информацию в линию обмена, организована работа по принципу запрос - ответ.
     87              Команда запроса в общей сложности занимает одно 11-битное слово. Первый бит слова - старт-бит, всегда является
     88              нулем. Старт-бит может быть только один. Затем идут 9 информационных бит (9-битовая передача информации), 
     89              начиная с младшего. Если старший бит является единицей, то передается команда (запрос), если же нуль - данные
     90              (ответ). Скорость обмена по линии составляет 2400 бит/с. Она сложилась исторически и связана с процессом работы
     91              информационной техники предыдущих поколений. Затем идет один стоп-бит. Вообще их может быть 1 или 2. Если 
     92              стоп-битов 2, то будет более точная проверка передачи слова, но более медленная скорость обработки. 
     93              Перед командой запроса всегда есть синхропауза (логическая 1), которая свидетельствует о том, что по линии 
     94              передается команда, а не данные. Это нужно для безошибочной работы по линии, т.к. система асинхронная и ведомое
     95              устройство может включиться не одновременно с ведущим устройством. Даже если устройство включится уже после 
     96              начала передачи ведущим команды, оно примет команду только после "полной" синхропаузы, которую будет ожидать в
     97              течение определённого протоколом обмена времени. Синхропауза всегда немного длиннее, чем 11-битное слово.
     98              Применение асинхронной системы позволяет использовать простой канал связи, который гораздо дешевле, чем при 
     99              синхронной системе. 
    100          */    
    101              for (;;)
    102              {  
    103                UCSR0B &= ~(1<<RXEN0);                   // отключение приемника USART
   \                     ??main_3:
   \   000000E6   910000C1           LDS     R16, 193
   \   000000EA   7E0F               ANDI    R16, 0xEF
   \   000000EC   930000C1           STS     193, R16
    104                count_bod = CBOD;                        // счетчик БОД
   \   000000F0   E004               LDI     R16, 4
   \   000000F2   9300....           STS     count_bod, R16
    105          
    106                do
    107                {
    108                  if (!(PIND & (1<<RX))) count_bod = CBOD;
   \                     ??main_4:
   \   000000F6   9948               SBIC    0x09, 0x00
   \   000000F8   C003               RJMP    ??main_5
   \   000000FA   E004               LDI     R16, 4
   \   000000FC   9300....           STS     count_bod, R16
    109                } while (count_bod);                     // ожидание СИНХРО-ПАУЗЫ (всегда только перед командой)
   \                     ??main_5:
   \   00000100   9100....           LDS     R16, count_bod
   \   00000104   2300               TST     R16
   \   00000106   F7B9               BRNE    ??main_4
    110          /*
    111                Выполнять присваивание count_bod = CBOD = 4, если RX = 0, пока count_bod - истина. Если же в течение четырёх
    112                периодов переполнения таймера0 с частотой 600 Гц, т.е. 6.7 мс, будет выполнено условие RX = 1, тогда
    113                программа уменьшит значение count_bod до нуля, условие while (count_bod) станет ложным и произойдёт 
    114                выход из цикла do/while. Только теперь устройство включится на приём. Таким образом, значение синхропаузы 
    115                составляет 6.7 мс.
    116          */     
    117                // приём данных по UART:
    118                UCSR0B |= (1<<RXEN0);                    // включение приемника USART
   \   00000108   910000C1           LDS     R16, 193
   \   0000010C   6100               ORI     R16, 0x10
   \   0000010E   930000C1           STS     193, R16
    119               
    120                for(int i=27; i>=0; i--)                 // приём семи 4-х байтовых регистров по UART
   \   00000112   E10B               LDI     R16, 27
   \   00000114   E010               LDI     R17, 0
   \                     ??main_6:
   \   00000116   2311               TST     R17
   \   00000118   F072               BRMI    ??main_7
    121                {
    122                  while (!(UCSR0A & (1<<RXC0)));         // ждем завершение приема байта
   \                     ??main_8:
   \   0000011A   9120....           LDS     R18, _A_UCSR0A
   \   0000011E   2F32               MOV     R19, R18
   \   00000120   FF37               SBRS    R19, 7
   \   00000122   CFFB               RJMP    ??main_8
    123                  R[i] = UDR0;                           // R6_4, R6_3,...,R6_1,...R0_1
   \   00000124   9120....           LDS     R18, _A_UDR0
   \   00000128   01F8               MOVW    R31:R30, R17:R16
   \   0000012A   ....               SUBI    R30, LOW((-(R) & 0xFFFF))
   \   0000012C   ....               SBCI    R31, (-(R) & 0xFFFF) >> 8
   \   0000012E   8320               ST      Z, R18
    124                }
   \   00000130   5001               SUBI    R16, 1
   \   00000132   4010               SBCI    R17, 0
   \   00000134   CFF0               RJMP    ??main_6
    125                
    126                // передача данных по SPI на ADF4350:
    127                ClearBit(PORTB, IN_SS0);                 // активация ведомого ADF4350
   \                     ??main_7:
   \   00000136   9828               CBI     0x05, 0x00
    128                
    129                for(int j=0; j>=5; j++)
   \   00000138   2444               CLR     R4
   \   0000013A   2455               CLR     R5
   \                     ??main_9:
   \   0000013C   E005               LDI     R16, 5
   \   0000013E   1640               CP      R4, R16
   \   00000140   E000               LDI     R16, 0
   \   00000142   0650               CPC     R5, R16
   \   00000144   F13C               BRLT    ??main_10
    130                {  
    131                  for(int i=(23-4*j); i>=(20-4*j); i--)  
   \   00000146   E127               LDI     R18, 23
   \   00000148   E030               LDI     R19, 0
   \   0000014A   0182               MOVW    R17:R16, R5:R4
   \   0000014C   0F00               LSL     R16
   \   0000014E   1F11               ROL     R17
   \   00000150   0F00               LSL     R16
   \   00000152   1F11               ROL     R17
   \   00000154   1B20               SUB     R18, R16
   \   00000156   0B31               SBC     R19, R17
   \   00000158   0139               MOVW    R7:R6, R19:R18
   \                     ??main_11:
   \   0000015A   E124               LDI     R18, 20
   \   0000015C   E030               LDI     R19, 0
   \   0000015E   0182               MOVW    R17:R16, R5:R4
   \   00000160   0F00               LSL     R16
   \   00000162   1F11               ROL     R17
   \   00000164   0F00               LSL     R16
   \   00000166   1F11               ROL     R17
   \   00000168   1B20               SUB     R18, R16
   \   0000016A   0B31               SBC     R19, R17
   \   0000016C   1662               CP      R6, R18
   \   0000016E   0673               CPC     R7, R19
   \   00000170   F054               BRLT    ??main_12
    132                  { 
    133                    SPI_Write(R[i]);                     // загрузка R5_4, R5_3,...,R5_1,...R0_1 по SPI в 32-разрядный буферный регистр
   \   00000172   01F3               MOVW    R31:R30, R7:R6
   \   00000174   ....               SUBI    R30, LOW((-(R) & 0xFFFF))
   \   00000176   ....               SBCI    R31, (-(R) & 0xFFFF) >> 8
   \   00000178   8100               LD      R16, Z
   \   0000017A   ....               RCALL   SPI_Write
    134                  }
   \   0000017C   EF0F               LDI     R16, 255
   \   0000017E   0E60               ADD     R6, R16
   \   00000180   EF0F               LDI     R16, 255
   \   00000182   1E70               ADC     R7, R16
   \   00000184   CFEA               RJMP    ??main_11
    135                
    136                  SetBit(PORTB, IN_LE);                  // загрузка данных, хранящихся в регистре сдвига, в один из регистров-защёлок
   \                     ??main_12:
   \   00000186   9A2E               SBI     0x05, 0x06
    137                  ClearBit(PORTB, IN_LE);
   \   00000188   982E               CBI     0x05, 0x06
    138                }
   \   0000018A   E001               LDI     R16, 1
   \   0000018C   0E40               ADD     R4, R16
   \   0000018E   E000               LDI     R16, 0
   \   00000190   1E50               ADC     R5, R16
   \   00000192   CFD4               RJMP    ??main_9
    139                
    140                SetBit(PORTB, IN_SS0);                   // деактивация ведомого ADF4350
   \                     ??main_10:
   \   00000194   9A28               SBI     0x05, 0x00
    141                
    142                unsigned char MSB, LSB;
    143                
    144                // передача данных по SPI на hmc1044lp3 Tfcf:
    145                MSB = R[27];   // xxxx 1111
   \   00000196   9100....           LDS     R16, (R + 27)
   \   0000019A   2F80               MOV     R24, R16
    146                MSB>>=1;       // xxxx x111
   \   0000019C   9586               LSR     R24
    147                MSB&=0x7;      // 0000 0111
   \   0000019E   7087               ANDI    R24, 0x07
    148                
    149                LSB = R[27];   // xxxx 1111
   \   000001A0   9100....           LDS     R16, (R + 27)
   \   000001A4   2F90               MOV     R25, R16
    150                LSB&=0x1;      // 0000 0001      
   \   000001A6   2F09               MOV     R16, R25
   \   000001A8   2F90               MOV     R25, R16
   \   000001AA   7091               ANDI    R25, 0x01
    151                LSB<<=7;       // 1000 0000
   \   000001AC   2F09               MOV     R16, R25
   \   000001AE   FB00               BST     R16, 0
   \   000001B0   E090               LDI     R25, 0
   \   000001B2   F997               BLD     R25, 7
    152                LSB+=0x0E;     // 1000 1110
   \   000001B4   5F92               SUBI    R25, 242
    153                
    154                ClearBit(PORTB, IN_SS1);                 // активация ведомого hmc1044lp3 Tfcf
   \   000001B6   982C               CBI     0x05, 0x04
    155                SPI_Write(MSB);                          // загрузка MSB по SPI
   \   000001B8   2F08               MOV     R16, R24
   \   000001BA   ....               RCALL   SPI_Write
    156                SPI_Write(LSB);                          // загрузка LSB по SPI 
   \   000001BC   2F09               MOV     R16, R25
   \   000001BE   ....               RCALL   SPI_Write
    157                SetBit(PORTB, IN_SS1);                   // деактивация ведомого hmc1044lp3 Tfcf
   \   000001C0   9A2C               SBI     0x05, 0x04
    158           
    159                // передача данных по SPI на hmc1044lp3 Rfcf:
    160                MSB = R[26];   // xxxx 1111
   \   000001C2   9100....           LDS     R16, (R + 26)
   \   000001C6   2F80               MOV     R24, R16
    161                MSB>>=1;       // xxxx x111
   \   000001C8   9586               LSR     R24
    162                MSB&=0x7;      // 0000 0111
   \   000001CA   7087               ANDI    R24, 0x07
    163                
    164                LSB = R[26];   // xxxx 1111
   \   000001CC   9100....           LDS     R16, (R + 26)
   \   000001D0   2F90               MOV     R25, R16
    165                LSB&=0x1;      // 0000 0001      
   \   000001D2   2F09               MOV     R16, R25
   \   000001D4   2F90               MOV     R25, R16
   \   000001D6   7091               ANDI    R25, 0x01
    166                LSB<<=7;       // 1000 0000
   \   000001D8   2F09               MOV     R16, R25
   \   000001DA   FB00               BST     R16, 0
   \   000001DC   E090               LDI     R25, 0
   \   000001DE   F997               BLD     R25, 7
    167                LSB+=0x0E;     // 1000 1110
   \   000001E0   5F92               SUBI    R25, 242
    168                
    169                ClearBit(PORTB, IN_SS2);                 // активация ведомого hmc1044lp3 Rfcf
   \   000001E2   982D               CBI     0x05, 0x05
    170                SPI_Write(MSB);                          // загрузка MSB по SPI
   \   000001E4   2F08               MOV     R16, R24
   \   000001E6   ....               RCALL   SPI_Write
    171                SPI_Write(LSB);                          // загрузка LSB по SPI 
   \   000001E8   2F09               MOV     R16, R25
   \   000001EA   ....               RCALL   SPI_Write
    172                SetBit(PORTB, IN_SS2);                   // деактивация ведомого hmc1044lp3 Rfcf
   \   000001EC   9A2D               SBI     0x05, 0x05
    173           
    174                unsigned char temp;
    175          
    176                // передача данных в параллельный порт на ADL5240 Rаf:
    177                temp = R[25];  // xx1x xxxx
   \   000001EE   9100....           LDS     R16, (R + 25)
   \   000001F2   2FA0               MOV     R26, R16
    178                temp>>=5;      // xxxx xxx1
   \   000001F4   95A2               SWAP    R26
   \   000001F6   70AF               ANDI    R26, 0x0F
   \   000001F8   95A6               LSR     R26
    179                temp&=1;       // 0000 0001
   \   000001FA   2F0A               MOV     R16, R26
   \   000001FC   2FA0               MOV     R26, R16
   \   000001FE   70A1               ANDI    R26, 0x01
    180                PORTE |= (temp<<ADLIN1_D1);
   \   00000200   2F0A               MOV     R16, R26
   \   00000202   0F00               LSL     R16
   \   00000204   0F00               LSL     R16
   \   00000206   0F00               LSL     R16
   \   00000208   B11E               IN      R17, 0x0E
   \   0000020A   2B10               OR      R17, R16
   \   0000020C   B91E               OUT     0x0E, R17
    181                
    182                temp = R[25];  // xxx1 xxxx
   \   0000020E   9100....           LDS     R16, (R + 25)
   \   00000212   2FA0               MOV     R26, R16
    183                temp>>=4;      // xxxx xxx1
   \   00000214   95A2               SWAP    R26
   \   00000216   70AF               ANDI    R26, 0x0F
    184                temp&=1;       // 0000 0001
   \   00000218   2F0A               MOV     R16, R26
   \   0000021A   2FA0               MOV     R26, R16
   \   0000021C   70A1               ANDI    R26, 0x01
    185                PORTE |= (temp<<ADLIN1_D2);
   \   0000021E   2F0A               MOV     R16, R26
   \   00000220   9502               SWAP    R16
   \   00000222   7F00               ANDI    R16, 0xF0
   \   00000224   B11E               IN      R17, 0x0E
   \   00000226   2B10               OR      R17, R16
   \   00000228   B91E               OUT     0x0E, R17
    186                
    187                temp = R[25];  // xxxx 1xxx
   \   0000022A   9100....           LDS     R16, (R + 25)
   \   0000022E   2FA0               MOV     R26, R16
    188                temp>>=3;      // xxxx xxx1
   \   00000230   95A6               LSR     R26
   \   00000232   95A6               LSR     R26
   \   00000234   95A6               LSR     R26
    189                temp&=1;       // 0000 0001
   \   00000236   2F0A               MOV     R16, R26
   \   00000238   2FA0               MOV     R26, R16
   \   0000023A   70A1               ANDI    R26, 0x01
    190                PORTE |= (temp<<ADLIN1_D3);      
   \   0000023C   2F0A               MOV     R16, R26
   \   0000023E   9502               SWAP    R16
   \   00000240   7F00               ANDI    R16, 0xF0
   \   00000242   0F00               LSL     R16
   \   00000244   B11E               IN      R17, 0x0E
   \   00000246   2B10               OR      R17, R16
   \   00000248   B91E               OUT     0x0E, R17
    191                
    192                temp = R[25];  // xxxx x1xx
   \   0000024A   9100....           LDS     R16, (R + 25)
   \   0000024E   2FA0               MOV     R26, R16
    193                temp>>=2;      // xxxx xxx1
   \   00000250   95A6               LSR     R26
   \   00000252   95A6               LSR     R26
    194                temp&=1;       // 0000 0001
   \   00000254   2F0A               MOV     R16, R26
   \   00000256   2FA0               MOV     R26, R16
   \   00000258   70A1               ANDI    R26, 0x01
    195                PORTE |= (temp<<ADLIN1_D4); 
   \   0000025A   E400               LDI     R16, 64
   \   0000025C   9FA0               MUL     R26, R16
   \   0000025E   B10E               IN      R16, 0x0E
   \   00000260   2900               OR      R16, R0
   \   00000262   B90E               OUT     0x0E, R16
    196                
    197                temp = R[25];  // xxxx xx1x
   \   00000264   9100....           LDS     R16, (R + 25)
   \   00000268   2FA0               MOV     R26, R16
    198                temp>>=1;      // xxxx xxx1
   \   0000026A   95A6               LSR     R26
    199                temp&=1;       // 0000 0001
   \   0000026C   2F0A               MOV     R16, R26
   \   0000026E   2FA0               MOV     R26, R16
   \   00000270   70A1               ANDI    R26, 0x01
    200                PORTE |= (temp<<ADLIN1_D5);      
   \   00000272   2F0A               MOV     R16, R26
   \   00000274   FB00               BST     R16, 0
   \   00000276   E000               LDI     R16, 0
   \   00000278   F907               BLD     R16, 7
   \   0000027A   B11E               IN      R17, 0x0E
   \   0000027C   2B10               OR      R17, R16
   \   0000027E   B91E               OUT     0x0E, R17
    201                
    202                temp = R[25];  // xxxx xxx1
   \   00000280   9100....           LDS     R16, (R + 25)
   \   00000284   2FA0               MOV     R26, R16
    203                temp&=1;       // 0000 0001
   \   00000286   2F0A               MOV     R16, R26
   \   00000288   2FA0               MOV     R26, R16
   \   0000028A   70A1               ANDI    R26, 0x01
    204                PORTF |= (temp<<ADLIN1_D6);    
   \   0000028C   B301               IN      R16, 0x11
   \   0000028E   2B0A               OR      R16, R26
   \   00000290   BB01               OUT     0x11, R16
    205                
    206                LED_TOGGLE;                              // светодиод меняет состояние на противоположное
   \   00000292   9B2D               SBIS    0x05, 0x05
   \   00000294   C002               RJMP    ??main_13
   \   00000296   982D               CBI     0x05, 0x05
   \   00000298   C001               RJMP    ??main_14
   \                     ??main_13:
   \   0000029A   9A2D               SBI     0x05, 0x05
    207                __watchdog_reset();
   \                     ??main_14:
   \   0000029C   95A8               WDR
   \   0000029E   CF23               RJMP    ??main_3
    208            }
    209           }
    210            return 0;
   \                     ??main_2:
   \   000002A0   E000               LDI     R16, 0
   \   000002A2   E010               LDI     R17, 0
   \   000002A4   E0E8               LDI     R30, 8
   \   000002A6   ........           JMP     ?EPILOGUE_B8_L09
   \   000002AA                      REQUIRE _A_DDRL
   \   000002AA                      REQUIRE _A_DDRK
   \   000002AA                      REQUIRE _A_DDRJ
   \   000002AA                      REQUIRE _A_DDRH
   \   000002AA                      REQUIRE _A_UDR0
   \   000002AA                      REQUIRE _A_UBRR0
   \   000002AA                      REQUIRE _A_UCSR0C
   \   000002AA                      REQUIRE _A_UCSR0B
   \   000002AA                      REQUIRE _A_UCSR0A
   \   000002AA                      REQUIRE _A_TIMSK0
   \   000002AA                      REQUIRE _A_WDTCSR
   \   000002AA                      REQUIRE _A_TCNT0
   \   000002AA                      REQUIRE _A_TCCR0B
   \   000002AA                      REQUIRE _A_TCCR0A
   \   000002AA                      REQUIRE _A_PORTG
   \   000002AA                      REQUIRE _A_DDRG
   \   000002AA                      REQUIRE _A_PORTF
   \   000002AA                      REQUIRE _A_DDRF
   \   000002AA                      REQUIRE _A_PORTE
   \   000002AA                      REQUIRE _A_DDRE
   \   000002AA                      REQUIRE _A_DDRD
   \   000002AA                      REQUIRE _A_PIND
   \   000002AA                      REQUIRE _A_DDRC
   \   000002AA                      REQUIRE _A_PORTB
   \   000002AA                      REQUIRE _A_DDRB
   \   000002AA                      REQUIRE _A_PINB
   \   000002AA                      REQUIRE _A_DDRA
    211          }
    212          /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
    213          /*                                                                                                          */
    214          /*                                               Подпрограммы                                               */
    215          /*                                                                                                          */
    216          /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
    217          #pragma vector=TIMER0_OVF_vect         // директива определяет вектор функции прерывания, описание которой следует за ней                 

   \                                 In  segment CODE, align 2, keep-with-next
    218          __interrupt void timer0_ovf_isr(void)  // функция прерывания по переполнению таймера0 
   \                     timer0_ovf_isr:
    219          {
   \   00000000   932A               ST      -Y, R18
   \   00000002   931A               ST      -Y, R17
   \   00000004   930A               ST      -Y, R16
   \   00000006   B71F               IN      R17, 0x3F
   \   00000008   B72B               IN      R18, 0x3B
    220            //TIMER0 has overflowed
    221            TCNT0  = RELOAD_TIM0;                // reload counter value
   \   0000000A   EB08               LDI     R16, 184
   \   0000000C   BD06               OUT     0x26, R16
    222          
    223            if (count_bod)  count_bod--;
   \   0000000E   9100....           LDS     R16, count_bod
   \   00000012   2300               TST     R16
   \   00000014   F029               BREQ    ??timer0_ovf_isr_0
   \   00000016   9100....           LDS     R16, count_bod
   \   0000001A   950A               DEC     R16
   \   0000001C   9300....           STS     count_bod, R16
    224          
    225            if(t_led_on)  t_led_on--;            // время подсвечивания --
   \                     ??timer0_ovf_isr_0:
   \   00000020   9100....           LDS     R16, t_led_on
   \   00000024   2300               TST     R16
   \   00000026   F031               BREQ    ??timer0_ovf_isr_1
   \   00000028   9100....           LDS     R16, t_led_on
   \   0000002C   950A               DEC     R16
   \   0000002E   9300....           STS     t_led_on, R16
   \   00000032   C001               RJMP    ??timer0_ovf_isr_2
    226            else          LED_OFF;               // LED-OFF
   \                     ??timer0_ovf_isr_1:
   \   00000034   9AA5               SBI     0x14, 0x05
    227          /*
    228            Частота переполнения таймера0 SYSTEM_TICK выбрана 600 Гц. Поэтому период переполнения таймера0 Tovf 
    229            составляет 1.7 мс, а константа перезагрузки 'TIM0' составляет RELOAD_TIM0 = 152(0x98). Подпрограмма 
    230            обработки прерывания по переполнению таймера0 вызывается каждые 1.7 мс, заново загружает константу 
    231            перезагрузки 'TIM0' и каждый раз уменьшает значение count_bod и t_led_on на единицу, пока значение 
    232            count_bod > 0 и t_led_on > 0. 
    233            Время горения светодиода будет T_LED_ON*Tovf = 120*1.7мс = 0.2c.
    234          */
    235          }
   \                     ??timer0_ovf_isr_2:
   \   00000036   BF2B               OUT     0x3B, R18
   \   00000038   BF1F               OUT     0x3F, R17
   \   0000003A   9109               LD      R16, Y+
   \   0000003C   9119               LD      R17, Y+
   \   0000003E   9129               LD      R18, Y+
   \   00000040   9518               RETI
   \   00000042                      REQUIRE _A_TCNT0
   \   00000042                      REQUIRE _A_PORTG
    236          
    237          // Подпрограмма инициализации SPI в режиме Master

   \                                 In  segment CODE, align 2, keep-with-next
    238          void SPI_MasterInit(void)
   \                     SPI_MasterInit:
    239          {
    240          /* 
    241            - Разрешение SPI в режиме мастера,
    242            - CPOL = 0 - генерируются тактовые импульсы положительной полярности,
    243            - CPHA = 0 - обработка данных производится по переднему фронту импульсов сигнала SCK,
    244            - установка скорости обмена fck/128 
    245          */
    246            SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0);
   \   00000000   E503               LDI     R16, 83
   \   00000002   BD0C               OUT     0x2C, R16
    247          }
   \   00000004   9508               RET
   \   00000006                      REQUIRE _A_SPCR
    248          
    249          // Подпрограмма записи по SPI

   \                                 In  segment CODE, align 2, keep-with-next
    250          void SPI_Write(unsigned char dataout)
   \                     SPI_Write:
    251          {
    252            // Запись байта в регист данных ведущего (инициализация передачи)
    253            SPDR = dataout;
   \   00000000   BD0E               OUT     0x2E, R16
    254            // Ожидание завершения передачи (пока бит SPIF не установлен)
    255            while(!(SPSR & (1<<SPIF)));
   \                     ??SPI_Write_0:
   \   00000002   B51D               IN      R17, 0x2D
   \   00000004   2F21               MOV     R18, R17
   \   00000006   FF27               SBRS    R18, 7
   \   00000008   CFFC               RJMP    ??SPI_Write_0
    256          }
   \   0000000A   9508               RET
   \   0000000C                      REQUIRE _A_SPDR
   \   0000000C                      REQUIRE _A_SPSR

   \                                 In  segment INTVEC, offset 0x5c, root
   \                     `??timer0_ovf_isr??INTVEC 92`:
   \   0000005C   ........           JMP     timer0_ovf_isr

   \                                 In  segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "-----------------`:
   \   00000000   2D2D2D2D2D2D       DC8 "------------------------------------"
   \              2D2D2D2D2D2D
   \              2D2D2D2D2D2D
   \              2D2D2D2D2D2D
   \              2D2D2D2D2D2D
   \              2D2D2D2D2D2D
   \              00          

   \                                 In  segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
   \                     `?<Constant "---------------------...">`:
   \   00000000                      DS8 37
   \   00000025                      REQUIRE `?<Initializer for <Constant "-----------------`

   Maximum stack usage in bytes:

     Function            CSTACK RSTACK
     --------            ------ ------
     SPI_MasterInit          0      2
     SPI_Write               0      2
     main                    8      2
       -> SPI_MasterInit     8      2
       -> uart_puts_p        8      2
       -> uart_putc          8      2
       -> uart_putc          8      2
       -> uart_puts          8      2
       -> uart_putc          8      2
       -> uart_putc          8      2
       -> SPI_Write          8      2
       -> SPI_Write          8      2
       -> SPI_Write          8      2
       -> SPI_Write          8      2
       -> SPI_Write          8      2
     timer0_ovf_isr          3      2


   Segment part sizes:

     Function/Label                                 Bytes
     --------------                                 -----
     Title                                            51
     _A_DDRL                                           1
     _A_DDRK                                           1
     _A_DDRJ                                           1
     _A_DDRH                                           1
     _A_UDR0                                           1
     _A_UBRR0                                          2
     _A_UCSR0C                                         1
     _A_UCSR0B                                         1
     _A_UCSR0A                                         1
     _A_TIMSK0                                         1
     _A_WDTCSR                                         1
     _A_SPDR                                           1
     _A_SPSR                                           1
     _A_SPCR                                           1
     _A_TCNT0                                          1
     _A_TCCR0B                                         1
     _A_TCCR0A                                         1
     _A_PORTG                                          1
     _A_DDRG                                           1
     _A_PORTF                                          1
     _A_DDRF                                           1
     _A_PORTE                                          1
     _A_DDRE                                           1
     _A_DDRD                                           1
     _A_PIND                                           1
     _A_DDRC                                           1
     _A_PORTB                                          1
     _A_DDRB                                           1
     _A_PINB                                           1
     _A_DDRA                                           1
     mode                                              1
     count_bod                                         1
     t_led_on                                          1
     R                                                28
     main                                            682
     timer0_ovf_isr                                   66
     SPI_MasterInit                                    6
     SPI_Write                                        12
     ??timer0_ovf_isr??INTVEC 92                       4
     ?<Initializer for <Constant "-----------------   37
     ?<Constant "---------------------...">           37
      Others                                          14

 
  31 bytes in segment ABSOLUTE
 766 bytes in segment CODE
  14 bytes in segment INITTAB
   4 bytes in segment INTVEC
  51 bytes in segment NEAR_F
  37 bytes in segment NEAR_I
  37 bytes in segment NEAR_ID
  31 bytes in segment NEAR_Z
 
 854 bytes of CODE memory (+ 18 bytes shared)
  68 bytes of DATA memory (+ 31 bytes shared)

Errors: none
Warnings: none
