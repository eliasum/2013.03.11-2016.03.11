/************************************************************************************************************/
/*                                                                                                          */
/*                      Управляющая программа для ATmega1280 в проекте "Интерфейс ADF4350"                  */
/*                                       Версия 1.1 (2013.09.24_15-51)                                      */
/*                                                                                                          */
/************************************************************************************************************/
#include "main.h"
#include <math.h>     
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
/*                                                                                                          */
/*                                        Главная функция программы                                         */
/*                                                                                                          */
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
int main( void )
{
  // задание интервала сброса WDT: 
  __watchdog_reset();                          // WDTCSR = WDIF WDIE WDP3 WDCE WDE WDP2 WDP1 WDP0 (XXXX XXXX)
  WDTCSR |= (1<<WDCE) | (1<<WDE);              // разрешение настройки/системного сброса WDT      (XXX1 1XXX)
  WDTCSR  = (1<<WDE)  | (1<<WDP3);             // установка тайм-аута = 512K циклов (~ 4.0 с)     (0010 1000)  
  
  // инициализация портов:
  DDRA = (1<<IN1_01)|(1<<IN1_02)|(1<<IN1_03)|(1<<IN1_04)|(1<<IN1_05)|(1<<IN1_06)|(1<<IN1_07)|(1<<IN1_08); // выходы
  
  PORTB = (1<<IN_SS0)|(1<<IN_SS1)|(1<<IN_SS2); // 1 на выходе
  DDRB = (1<<IN_SS0)|(1<<IN_SCK)|(1<<IN_MOSI)|(1<<IN_SS1)|(1<<IN_SS2)|(1<<IN_LE); // выходы
  
  DDRC = (1<<IN1_09)|(1<<IN1_10)|(1<<IN1_11)|(1<<IN1_12)|(1<<IN1_13)|(1<<IN1_14)|(1<<IN1_15)|(1<<IN1_16); // выходы

  DDRD = (1<<IN2_01)|(1<<IN2_02)|(1<<IN2_03)|(1<<IN2_04)|(1<<IN2_05)|(1<<IN2_06)|(1<<IN2_07)|(1<<IN2_08); // выходы

  PORTE = (1<<RX)|(1<<TX); // подтяжка на питание или 1 на выходе
  DDRE = (1<<TX)|(1<<ADLIN1_D0)|(1<<ADLIN1_D1)|(1<<ADLIN1_D2)|(1<<ADLIN1_D3)|(1<<ADLIN1_D4)|(1<<ADLIN1_D5); // выходы

  DDRF = (1<<ADLIN1_D6)|(1<<ADLIN2_D0)|(1<<ADLIN2_D1)|(1<<ADLIN2_D2)|(1<<ADLIN2_D3)|(1<<ADLIN2_D4)|(1<<ADLIN2_D5)|(1<<ADLIN2_D6); // выходы
  
  PORTG = (1<<LED); // 1 на выходе
  DDRG = (1<<IN4_09)|(1<<IN4_10)|(1<<IN4_11)|(1<<IN4_12)|(1<<IN4_13)|(1<<LED); // выходы
  
  DDRH = (1<<IN2_09)|(1<<IN2_10)|(1<<IN2_11)|(1<<IN2_12)|(1<<IN2_13)|(1<<IN2_14)|(1<<IN2_15)|(1<<IN2_16); // выходы
  
  DDRJ = (1<<IN3_01)|(1<<IN3_02)|(1<<IN3_03)|(1<<IN3_04)|(1<<IN3_05)|(1<<IN3_06)|(1<<IN3_07)|(1<<IN3_08); // выходы

  DDRK = (1<<IN3_09)|(1<<IN3_10)|(1<<IN3_11)|(1<<IN3_12)|(1<<IN3_13)|(1<<IN3_14)|(1<<IN3_15)|(1<<IN3_16); // выходы

  DDRL = (1<<IN4_01)|(1<<IN4_02)|(1<<IN4_03)|(1<<IN4_04)|(1<<IN4_05)|(1<<IN4_06)|(1<<IN4_07)|(1<<IN4_08); // выходы

  if (PINB & (1<<DEBUG)) mode = 1; else mode = 0; // выбор режима работы устройства
  
  count_bod = 1;                                  // минимум 1 прерывание
  t_led_on  = 0;                                  // время индикации
  
  __watchdog_reset();                             // 1-й "простой" cброс сторожевого таймера
  __enable_interrupt();                           // прерывания разрешаем
  
//////////////////////////////////////////Режим отладки/////////////////////////////////////////////////////// 
  if(mode)
  {
    // инициализация USART (2400):
    UCSR0A = 0x00;                             // запрет настроек USART на время установки скорости передачи
    UCSR0B = 0x00;                             
    UCSR0C = 0x06;                             // размер слова данных 8 бит
    UBRR0L = UBBR_2K4L;                        // задание скорости 2400
    UBRR0H = UBBR_2K4L;   
    UCSR0B = 0x0C;                             // разрешение передачи (TXENn = 1); 9-Bit

    // инициализация Т/С0:
    TCCR0B = 0x00;                             // останов Т/С0
    TCNT0  = RELOAD_TIM0;                      // нач. знач-е
    TCCR0A = 0x00;
    TCCR0B = START_TIM0;                       // таймер запускаем
    TIMSK0 = 0x01;                             // Т/С0 <- источник прерываний
    
    SPI_MasterInit();                          // инициализация SPI в режиме Master
   
    // вывод строки из ПЗУ, uart_putc(0x0a); - перевод на след. строку  
    uart_puts_p(Title);                                 uart_putc(0x0d); uart_putc(0x0a);                        
    uart_puts("------------------------------------");  uart_putc(0x0d); uart_putc(0x0a);
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
          
                                   //Организация работы линии обмена                   
          
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
    Организация работы линии обмена.
    В системе может быть несколько ведомых устройств. Поэтому чтобы не было коллизий, когда устройства 
    одновременно посылают информацию в линию обмена, организована работа по принципу запрос - ответ.
    Команда запроса в общей сложности занимает одно 11-битное слово. Первый бит слова - старт-бит, всегда является
    нулем. Старт-бит может быть только один. Затем идут 9 информационных бит (9-битовая передача информации), 
    начиная с младшего. Если старший бит является единицей, то передается команда (запрос), если же нуль - данные
    (ответ). Скорость обмена по линии составляет 2400 бит/с. Она сложилась исторически и связана с процессом работы
    информационной техники предыдущих поколений. Затем идет один стоп-бит. Вообще их может быть 1 или 2. Если 
    стоп-битов 2, то будет более точная проверка передачи слова, но более медленная скорость обработки. 
    Перед командой запроса всегда есть синхропауза (логическая 1), которая свидетельствует о том, что по линии 
    передается команда, а не данные. Это нужно для безошибочной работы по линии, т.к. система асинхронная и ведомое
    устройство может включиться не одновременно с ведущим устройством. Даже если устройство включится уже после 
    начала передачи ведущим команды, оно примет команду только после "полной" синхропаузы, которую будет ожидать в
    течение определённого протоколом обмена времени. Синхропауза всегда немного длиннее, чем 11-битное слово.
    Применение асинхронной системы позволяет использовать простой канал связи, который гораздо дешевле, чем при 
    синхронной системе. 
*/    
    for (;;)
    {  
      UCSR0B &= ~(1<<RXEN0);                   // отключение приемника USART
      count_bod = CBOD;                        // счетчик БОД

      do
      {
        if (!(PIND & (1<<RX))) count_bod = CBOD;
      } while (count_bod);                     // ожидание СИНХРО-ПАУЗЫ (всегда только перед командой)
/*
      Выполнять присваивание count_bod = CBOD = 4, если RX = 0, пока count_bod - истина. Если же в течение четырёх
      периодов переполнения таймера0 с частотой 600 Гц, т.е. 6.7 мс, будет выполнено условие RX = 1, тогда
      программа уменьшит значение count_bod до нуля, условие while (count_bod) станет ложным и произойдёт 
      выход из цикла do/while. Только теперь устройство включится на приём. Таким образом, значение синхропаузы 
      составляет 6.7 мс.
*/     
      // приём данных по UART:
      UCSR0B |= (1<<RXEN0);                    // включение приемника USART
     
      for(int i=27; i>=0; i--)                 // приём семи 4-х байтовых регистров по UART
      {
        while (!(UCSR0A & (1<<RXC0)));         // ждем завершение приема байта
        R[i] = UDR0;                           // R6_4, R6_3,...,R6_1,...R0_1
      }
      
      // передача данных по SPI на ADF4350:
      ClearBit(PORTB, IN_SS0);                 // активация ведомого ADF4350
      
      for(int j=0; j>=5; j++)
      {  
        for(int i=(23-4*j); i>=(20-4*j); i--)  
        { 
          SPI_Write(R[i]);                     // загрузка R5_4, R5_3,...,R5_1,...R0_1 по SPI в 32-разрядный буферный регистр
        }
      
        SetBit(PORTB, IN_LE);                  // загрузка данных, хранящихся в регистре сдвига, в один из регистров-защёлок
        ClearBit(PORTB, IN_LE);
      }
      
      SetBit(PORTB, IN_SS0);                   // деактивация ведомого ADF4350
      
      unsigned char MSB, LSB;
      
      // передача данных по SPI на hmc1044lp3 Tfcf:
      MSB = R[27];   // xxxx 1111
      MSB>>=1;       // xxxx x111
      MSB&=0x7;      // 0000 0111
      
      LSB = R[27];   // xxxx 1111
      LSB&=0x1;      // 0000 0001      
      LSB<<=7;       // 1000 0000
      LSB+=0x0E;     // 1000 1110
      
      ClearBit(PORTB, IN_SS1);                 // активация ведомого hmc1044lp3 Tfcf
      SPI_Write(MSB);                          // загрузка MSB по SPI
      SPI_Write(LSB);                          // загрузка LSB по SPI 
      SetBit(PORTB, IN_SS1);                   // деактивация ведомого hmc1044lp3 Tfcf
 
      // передача данных по SPI на hmc1044lp3 Rfcf:
      MSB = R[26];   // xxxx 1111
      MSB>>=1;       // xxxx x111
      MSB&=0x7;      // 0000 0111
      
      LSB = R[26];   // xxxx 1111
      LSB&=0x1;      // 0000 0001      
      LSB<<=7;       // 1000 0000
      LSB+=0x0E;     // 1000 1110
      
      ClearBit(PORTB, IN_SS2);                 // активация ведомого hmc1044lp3 Rfcf
      SPI_Write(MSB);                          // загрузка MSB по SPI
      SPI_Write(LSB);                          // загрузка LSB по SPI 
      SetBit(PORTB, IN_SS2);                   // деактивация ведомого hmc1044lp3 Rfcf
 
      unsigned char temp;

      // передача данных в параллельный порт на ADL5240 Rаf:
      temp = R[25];  // xx1x xxxx
      temp>>=5;      // xxxx xxx1
      temp&=1;       // 0000 0001
      PORTE |= (temp<<ADLIN1_D1);
      
      temp = R[25];  // xxx1 xxxx
      temp>>=4;      // xxxx xxx1
      temp&=1;       // 0000 0001
      PORTE |= (temp<<ADLIN1_D2);
      
      temp = R[25];  // xxxx 1xxx
      temp>>=3;      // xxxx xxx1
      temp&=1;       // 0000 0001
      PORTE |= (temp<<ADLIN1_D3);      
      
      temp = R[25];  // xxxx x1xx
      temp>>=2;      // xxxx xxx1
      temp&=1;       // 0000 0001
      PORTE |= (temp<<ADLIN1_D4); 
      
      temp = R[25];  // xxxx xx1x
      temp>>=1;      // xxxx xxx1
      temp&=1;       // 0000 0001
      PORTE |= (temp<<ADLIN1_D5);      
      
      temp = R[25];  // xxxx xxx1
      temp&=1;       // 0000 0001
      PORTF |= (temp<<ADLIN1_D6);    
      
      LED_TOGGLE;                              // светодиод меняет состояние на противоположное
      __watchdog_reset();
  }
 }
  return 0;
}
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
/*                                                                                                          */
/*                                               Подпрограммы                                               */
/*                                                                                                          */
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
#pragma vector=TIMER0_OVF_vect         // директива определяет вектор функции прерывания, описание которой следует за ней                 
__interrupt void timer0_ovf_isr(void)  // функция прерывания по переполнению таймера0 
{
  //TIMER0 has overflowed
  TCNT0  = RELOAD_TIM0;                // reload counter value

  if (count_bod)  count_bod--;

  if(t_led_on)  t_led_on--;            // время подсвечивания --
  else          LED_OFF;               // LED-OFF
/*
  Частота переполнения таймера0 SYSTEM_TICK выбрана 600 Гц. Поэтому период переполнения таймера0 Tovf 
  составляет 1.7 мс, а константа перезагрузки 'TIM0' составляет RELOAD_TIM0 = 152(0x98). Подпрограмма 
  обработки прерывания по переполнению таймера0 вызывается каждые 1.7 мс, заново загружает константу 
  перезагрузки 'TIM0' и каждый раз уменьшает значение count_bod и t_led_on на единицу, пока значение 
  count_bod > 0 и t_led_on > 0. 
  Время горения светодиода будет T_LED_ON*Tovf = 120*1.7мс = 0.2c.
*/
}

// Подпрограмма инициализации SPI в режиме Master
void SPI_MasterInit(void)
{
/* 
  - Разрешение SPI в режиме мастера,
  - CPOL = 0 - генерируются тактовые импульсы положительной полярности,
  - CPHA = 0 - обработка данных производится по переднему фронту импульсов сигнала SCK,
  - установка скорости обмена fck/128 
*/
  SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0);
}

// Подпрограмма записи по SPI
void SPI_Write(unsigned char dataout)
{
  // Запись байта в регист данных ведущего (инициализация передачи)
  SPDR = dataout;
  // Ожидание завершения передачи (пока бит SPIF не установлен)
  while(!(SPSR & (1<<SPIF)));
}