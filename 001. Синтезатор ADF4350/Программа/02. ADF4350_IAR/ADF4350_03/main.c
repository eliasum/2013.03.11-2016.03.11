/************************************************************************************************************/
/*                                                                                                          */
/*                      Управляющая программа для ATmega1280 в проекте "Интерфейс ADF4350"                  */
/*                                       Версия 1.2 (2013.10.24_12-58)                                      */
/*                                                                                                          */
/************************************************************************************************************/
#include "main.h"
#include <math.h>     
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
/*                                                                                                          */
/*                                        Главная функция программы                                         */
/*                                                                                                          */
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
void main( void )
{
  // задание интервала сброса WDT: 
  __watchdog_reset();                          // WDTCSR = WDIF WDIE WDP3 WDCE WDE WDP2 WDP1 WDP0 (XXXX XXXX)
  WDTCSR |= (1<<WDCE) | (1<<WDE);              // разрешение настройки/системного сброса WDT      (XXX1 1XXX)
  WDTCSR  = (1<<WDE)  | (1<<WDP3);             // установка тайм-аута = 512K циклов (~ 4.0 с)     (0010 1000)  
  
  // инициализация портов:
  DDRA = (1<<IN1_01)|(1<<IN1_02)|(1<<IN1_03)|(1<<IN1_04)|(1<<IN1_05)|(1<<IN1_06)|(1<<IN1_07)|(1<<IN1_08); // выходы
  
  PORTB = (1<<IN_SS0)|(1<<IN_SS1)|(1<<IN_SS2); // 1 на выходе
  DDRB = (1<<IN_SS0)|(1<<IN_SCK)|(1<<IN_MOSI)|(1<<IN_SS1)|(1<<IN_SS2)|(1<<IN_LE); // выходы
  
  DDRC = (1<<IN1_09)|(1<<IN1_10)|(1<<IN1_11)|(1<<IN1_12)|(1<<IN1_13)|(1<<IN1_14)|(1<<IN1_15)|(1<<IN1_16); // выходы

  DDRD = (1<<IN2_01)|(1<<IN2_02)|(1<<IN2_03)|(1<<IN2_04)|(1<<IN2_05)|(1<<IN2_06)|(1<<IN2_07)|(1<<IN2_08); // выходы

  PORTE = (1<<RX)|(1<<TX); // подтяжка на питание или 1 на выходе
  DDRE = (1<<TX)|(1<<ADLIN1_D0)|(1<<ADLIN1_D1)|(1<<ADLIN1_D2)|(1<<ADLIN1_D3)|(1<<ADLIN1_D4)|(1<<ADLIN1_D5); // выходы

  DDRF = (1<<ADLIN1_D6)|(1<<ADLIN2_D0)|(1<<ADLIN2_D1)|(1<<ADLIN2_D2)|(1<<ADLIN2_D3)|(1<<ADLIN2_D4)|(1<<ADLIN2_D5)|(1<<ADLIN2_D6); // выходы
  
  PORTG = (1<<LED); // 1 на выходе
  DDRG = (1<<IN4_09)|(1<<IN4_10)|(1<<IN4_11)|(1<<IN4_12)|(1<<IN4_13)|(1<<LED); // выходы
  
  DDRH = (1<<IN2_09)|(1<<IN2_10)|(1<<IN2_11)|(1<<IN2_12)|(1<<IN2_13)|(1<<IN2_14)|(1<<IN2_15)|(1<<IN2_16); // выходы
  
  DDRJ = (1<<IN3_01)|(1<<IN3_02)|(1<<IN3_03)|(1<<IN3_04)|(1<<IN3_05)|(1<<IN3_06)|(1<<IN3_07)|(1<<IN3_08); // выходы

  DDRK = (1<<IN3_09)|(1<<IN3_10)|(1<<IN3_11)|(1<<IN3_12)|(1<<IN3_13)|(1<<IN3_14)|(1<<IN3_15)|(1<<IN3_16); // выходы

  DDRL = (1<<IN4_01)|(1<<IN4_02)|(1<<IN4_03)|(1<<IN4_04)|(1<<IN4_05)|(1<<IN4_06)|(1<<IN4_07)|(1<<IN4_08); // выходы

  count_bod = 1;                                  // минимум 1 прерывание
  t_led_on  = 0;                                  // время индикации
  count     = 0;
  
  __watchdog_reset();                             // 1-й "простой" cброс сторожевого таймера
  __enable_interrupt();                           // прерывания разрешаем
  
  // инициализация USART (2400):
  UCSR0A = 0x00;                             // запрет настроек USART на время установки скорости передачи
  UCSR0B = 0x00;                             
  UCSR0C = 0x06;                             // размер слова данных 8 бит
  UBRR0L = UBBR_2K4L;                        // задание скорости 2400
  UBRR0H = UBBR_2K4H;   
  UCSR0B = 0x08;                             // разрешение передачи (TXENn = 1)

  // инициализация Т/С0:
  TCCR0B = 0x00;                             // останов Т/С0
  TCNT0  = RELOAD_TIM0;                      // нач. знач-е
  TCCR0A = 0x00;
  TCCR0B = START_TIM0;                       // таймер запускаем
  TIMSK0 = 0x01;                             // Т/С0 <- источник прерываний
    
  SPI_MasterInit();                          // инициализация SPI в режиме Master
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
          
                                   //Организация работы линии обмена                   
          
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
  Перед началом передачи пакета данных всегда есть синхропауза (логическая 1). Это нужно для безошибочной работы
  по линии, т.к. система асинхронная и ведомое устройство может включиться не одновременно с ведущим устройством. 
  Даже если устройство включится уже после начала передачи ведущим, оно примет данные только после "полной" 
  синхропаузы, которую будет ожидать. Длина синхропаузы больше, чем длина одного слова данных.
  Применение асинхронной системы позволяет использовать простой канал связи, который гораздо дешевле, чем при 
  синхронной системе. 
*/    
  for (;;)
  {     
    UCSR0B &= ~(1<<RXEN0);                   // отключение приемника USART
    count_bod = CBOD;                        // счетчик БОД

    do
    {
      if (!(PINE & (1<<RX))) count_bod = CBOD;
    } while (count_bod);                     // ожидание СИНХРО-ПАУЗЫ (всегда только перед командой)
/*
    Выполнять присваивание count_bod = CBOD = 4, если RX = 0, пока count_bod - истина. Если же в течение четырёх
    периодов переполнения таймера0 с частотой 600 Гц, т.е. 6.7 мс, будет выполнено условие RX = 1, тогда
    программа уменьшит значение count_bod до нуля, условие while (count_bod) станет ложным и произойдёт 
    выход из цикла do/while. Только теперь устройство включится на приём. Таким образом, значение синхропаузы 
    составляет 6.7 мс. Начало приёма происходит при обнаружении старт-бита (логический 0).
*/     
    // приём данных по UART:
/*
    Вперёд старший регистр. Вперёд старший байт.
*/
    UCSR0B |= (1<<RXEN0);                    // включение приемника USART
     
    for(int i=27; i>=0; i--)                 // приём семи 4-х байтовых регистров по UART
    {
      while (!(UCSR0A & (1<<RXC0)));         // ждем завершение приема байта
      R[i] = UDR0;                           // R6_4, R6_3,...,R6_1,...R0_1
    }

    t_led_on  = T_LED_ON;                    // время подсвечивания
    LED_ON;   
      
    unsigned char ONE, TWO;
      
    // передача данных по SPI на hmc1044lp3 Tfcf:
/*
    D8D7D6D5D4D3D2D1 D0A3A2A1A0CA2CA1CA0 - 2 байта для передачи по SPI на hmc1044lp3, где
    D8D7D6D5D4D3D2D1D0 - данные;
    A3A2A1A0 - адрес регистра = 01h;
    CA2CA1CA0 - адрес чипа = 110b.
*/
    ClearBit(PORTB, IN_SS0);                   // деактивация ведомого ADF4350
      
    ONE = R[27];   // xxxx 1111 
    ONE>>=1;       // xxxx x111
    ONE&=0x7;      // 0000 0111 первый байт - данные без D0
      
    TWO = R[27];   // xxxx 1111
    TWO&=0x1;      // 0000 0001   
    TWO<<=7;       // 1000 0000
    TWO+=0x0E;     // 1000 1110 второй байт - D0, адреса регистра и чипа 
      
    ClearBit(PORTB, IN_SS1);                 // активация ведомого hmc1044lp3 Tfcf
    SPI_Write(ONE);                          // загрузка ONE по SPI
    SPI_Write(TWO);                          // загрузка TWO по SPI 
    SetBit(PORTB, IN_SS1);                   // деактивация ведомого hmc1044lp3 Tfcf
      
    SetBit(PORTB, IN_SS0);                   // активация ведомого ADF4350
 
    // передача данных по SPI на hmc1044lp3 Rfcf:
/*
    D8D7D6D5D4D3D2D1 D0A3A2A1A0CA2CA1CA0 - 2 байта для передачи по SPI на hmc1044lp3, где
    D8D7D6D5D4D3D2D1D0 - данные;
    A3A2A1A0 - адрес регистра = 01h;
    CA2CA1CA0 - адрес чипа = 110b.
*/     
    ClearBit(PORTB, IN_SS0);                 // деактивация ведомого ADF4350
      
    ONE = R[26];   // xxxx 1111
    ONE>>=1;       // xxxx x111
    ONE&=0x7;      // 0000 0111 первый байт - данные без D0
      
    TWO = R[26];   // xxxx 1111
    TWO&=0x1;      // 0000 0001      
    TWO<<=7;       // 1000 0000
    TWO+=0x0E;     // 1000 1110 второй байт - D0, адреса регистра и чипа
      
    ClearBit(PORTB, IN_SS2);                 // активация ведомого hmc1044lp3 Rfcf
    SPI_Write(ONE);                          // загрузка ONE по SPI
    SPI_Write(TWO);                          // загрузка TWO по SPI 
    SetBit(PORTB, IN_SS2);                   // деактивация ведомого hmc1044lp3 Rfcf
      
    SetBit(PORTB, IN_SS0);                   // активация ведомого ADF4350
     
    // передача данных по SPI на ADF4350:
    for(int j=0; j<=5; j++)
    {  
      for(int i=(23-4*j); i>=(20-4*j); i--)  
      { 
        SPI_Write(R[i]);                     // загрузка R5_4, R5_3,...,R5_1,...R0_1 по SPI в 32-разрядный буферный регистр
      }
      
      SetBit(PORTB, IN_LE);                  // загрузка данных, хранящихся в регистре сдвига, в один из регистров-защёлок
      ClearBit(PORTB, IN_LE);
    }
            
    unsigned char temp;
      
    // передача данных в параллельный порт на ADL5240 Tаf:
    temp = R[25];  // xx1x xxxx
    temp>>=5;      // xxxx xxx1
    temp&=1;       // 0000 0001
    PORTE |= (temp<<ADLIN1_D1);
      
    temp = R[25];  // xxx1 xxxx
    temp>>=4;      // xxxx xxx1
    temp&=1;       // 0000 0001
    PORTE |= (temp<<ADLIN1_D2);
      
    temp = R[25];  // xxxx 1xxx
    temp>>=3;      // xxxx xxx1
    temp&=1;       // 0000 0001
    PORTE |= (temp<<ADLIN1_D3);      
      
    temp = R[25];  // xxxx x1xx
    temp>>=2;      // xxxx xxx1
    temp&=1;       // 0000 0001
    PORTE |= (temp<<ADLIN1_D4); 
      
    temp = R[25];  // xxxx xx1x
    temp>>=1;      // xxxx xxx1
    temp&=1;       // 0000 0001
    PORTE |= (temp<<ADLIN1_D5);      
      
    temp = R[25];  // xxxx xxx1
    temp&=1;       // 0000 0001
    PORTF |= (temp<<ADLIN1_D6);  
      
    // передача данных в параллельный порт на ADL5240 Rаf:
    temp = R[24];  // xx1x xxxx
    temp>>=5;      // xxxx xxx1
    temp&=1;       // 0000 0001
    PORTF |= (temp<<ADLIN2_D1);
      
    temp = R[24];  // xxx1 xxxx
    temp>>=4;      // xxxx xxx1
    temp&=1;       // 0000 0001
    PORTF |= (temp<<ADLIN2_D2);
      
    temp = R[24];  // xxxx 1xxx
    temp>>=3;      // xxxx xxx1
    temp&=1;       // 0000 0001
    PORTF |= (temp<<ADLIN2_D3);      
      
    temp = R[24];  // xxxx x1xx
    temp>>=2;      // xxxx xxx1
    temp&=1;       // 0000 0001
    PORTF |= (temp<<ADLIN2_D4); 
      
    temp = R[24];  // xxxx xx1x
    temp>>=1;      // xxxx xxx1
    temp&=1;       // 0000 0001
    PORTF |= (temp<<ADLIN2_D5);      
      
    temp = R[24];  // xxxx xxx1
    temp&=1;       // 0000 0001
    PORTF |= (temp<<ADLIN2_D6);      

    __watchdog_reset();
  }
}
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
/*                                                                                                          */
/*                                               Подпрограммы                                               */
/*                                                                                                          */
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
#pragma vector=TIMER0_OVF_vect         // директива определяет вектор функции прерывания, описание которой следует за ней                 
__interrupt void timer0_ovf_isr(void)  // функция прерывания по переполнению таймера0 
{
  //TIMER0 has overflowed
  TCNT0  = RELOAD_TIM0;                // reload counter value

  if (count_bod)  count_bod--;

  if(t_led_on)  t_led_on--;            // время подсвечивания --
  else          LED_OFF;               // LED-OFF
/*
  Частота переполнения таймера0 SYSTEM_TICK выбрана 600 Гц. Поэтому период переполнения таймера0 Tovf 
  составляет 1.7 мс, а константа перезагрузки 'TIM0' составляет RELOAD_TIM0 = 152(0x98). Подпрограмма 
  обработки прерывания по переполнению таймера0 вызывается каждые 1.7 мс, заново загружает константу 
  перезагрузки 'TIM0' и каждый раз уменьшает значение count_bod и t_led_on на единицу, пока значение 
  count_bod > 0 и t_led_on > 0. 
  Время горения светодиода будет T_LED_ON*Tovf = 120*1.7мс = 0.2c.
*/
}

// Подпрограмма инициализации SPI в режиме Master
void SPI_MasterInit(void)
{
/* 
  - Разрешение SPI в режиме мастера,
  - CPOL = 1 - генерируются тактовые импульсы отрицательной полярности,
  - CPHA = 0 - обработка данных производится по переднему спадающему фронту импульсов сигнала SCK,
  - установка скорости обмена fck/128 
*/
  SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0)|(1<<CPOL);
}

// Подпрограмма записи по SPI
void SPI_Write(unsigned char dataout)
{
  // Запись байта в регист данных ведущего (инициализация передачи)
  SPDR = dataout;
  // Ожидание завершения передачи (пока бит SPIF не установлен)
  while(!(SPSR & (1<<SPIF)));
}