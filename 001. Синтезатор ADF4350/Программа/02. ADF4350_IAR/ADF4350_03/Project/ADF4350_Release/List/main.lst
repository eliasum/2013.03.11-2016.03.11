###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.50.0.50277/W32 for Atmel AVR    30/Oct/2013  14:24:38 #
# Copyright (C) 1996-2010 IAR Systems AB.                                     #
#                                                                             #
#    Source file  =  D:\_IAR projects\ADF4350_IAR_ver.1\ADF4350_03\main.c     #
#    Command line =  "D:\_IAR projects\ADF4350_IAR_ver.1\ADF4350_03\main.c"   #
#                    --cpu=m1280 -ms -o "D:\_IAR                              #
#                    projects\ADF4350_IAR_ver.1\ADF4350_03\Project\ADF4350_Re #
#                    lease\Obj\" -D NDEBUG -lCN "D:\_IAR                      #
#                    projects\ADF4350_IAR_ver.1\ADF4350_03\Project\ADF4350_Re #
#                    lease\List\" -y --initializers_in_flash -s2 --no_cse     #
#                    --no_inline --no_code_motion --no_cross_call             #
#                    --no_clustering --no_tbaa -DENABLE_BIT_DEFINITIONS -e    #
#                    -I "E:\Program Files\IAR Systems\Embedded Workbench      #
#                    5.4\avr\INC\" -I "E:\Program Files\IAR Systems\Embedded  #
#                    Workbench 5.4\avr\INC\CLIB\" --eeprom_size 4096          #
#    List file    =  D:\_IAR projects\ADF4350_IAR_ver.1\ADF4350_03\Project\AD #
#                    F4350_Release\List\main.lst                              #
#    Object file  =  D:\_IAR projects\ADF4350_IAR_ver.1\ADF4350_03\Project\AD #
#                    F4350_Release\Obj\main.r90                               #
#                                                                             #
#                                                                             #
###############################################################################

D:\_IAR projects\ADF4350_IAR_ver.1\ADF4350_03\main.c
      1          /************************************************************************************************************/
      2          /*                                                                                                          */
      3          /*                      Управляющая программа для ATmega1280 в проекте "Интерфейс ADF4350"                  */
      4          /*                                       Версия 1.2 (2013.10.24_12-58)                                      */
      5          /*                                                                                                          */
      6          /************************************************************************************************************/
      7          #include "main.h"

   \                                 In  segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash Title[51]
   \                     Title:
   \   00000000   444134463533       DC8 41H, 44H, 46H, 34H, 33H, 35H, 30H, 20H
   \              2030        
   \   00000008   202D69576564       DC8 2DH, 20H, 57H, 69H, 64H, 65H, 62H, 61H
   \              6162        
   \   00000010   646E53206E79       DC8 6EH, 64H, 20H, 53H, 79H, 6EH, 74H, 68H
   \              6874        
   \   00000018   73657A697265       DC8 65H, 73H, 69H, 7AH, 65H, 72H, 20H, 77H
   \              7720        
   \   00000020   746920686E49       DC8 69H, 74H, 68H, 20H, 49H, 6EH, 74H, 65H
   \              6574        
   \   00000028   726774616465       DC8 67H, 72H, 61H, 74H, 65H, 64H, 20H, 56H
   \              5620        
   \   00000030   4F4300             DC8 43H, 4FH, 0

   \                                 In  segment ABSOLUTE, at 0x10a
   \   <__C51> volatile __ext_io _A_DDRL
   \                     _A_DDRL:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x107
   \   <__C60> volatile __ext_io _A_DDRK
   \                     _A_DDRK:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x104
   \   <__C69> volatile __ext_io _A_DDRJ
   \                     _A_DDRJ:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x101
   \   <__C78> volatile __ext_io _A_DDRH
   \                     _A_DDRH:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc6
   \   <__C115> volatile __io _A_UDR0
   \                     _A_UDR0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc4
   \   <__C119> volatile __io _A_UBRR0
   \                     _A_UBRR0:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0xc2
   \   <__C123> volatile __io _A_UCSR0C
   \                     _A_UCSR0C:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc1
   \   <__C126> volatile __io _A_UCSR0B
   \                     _A_UCSR0B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc0
   \   <__C129> volatile __io _A_UCSR0A
   \                     _A_UCSR0A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x6e
   \   <__C293> volatile __io _A_TIMSK0
   \                     _A_TIMSK0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x60
   \   <__C325> volatile __io _A_WDTCSR
   \                     _A_WDTCSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x4e
   \   <__C359> volatile __io _A_SPDR
   \                     _A_SPDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x4d
   \   <__C362> volatile __io _A_SPSR
   \                     _A_SPSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x4c
   \   <__C365> volatile __io _A_SPCR
   \                     _A_SPCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x46
   \   <__C375> volatile __io _A_TCNT0
   \                     _A_TCNT0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x45
   \   <__C378> volatile __io _A_TCCR0B
   \                     _A_TCCR0B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x44
   \   <__C381> volatile __io _A_TCCR0A
   \                     _A_TCCR0A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x34
   \   <__C425> volatile __io _A_PORTG
   \                     _A_PORTG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x33
   \   <__C428> volatile __io _A_DDRG
   \                     _A_DDRG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x31
   \   <__C434> volatile __io _A_PORTF
   \                     _A_PORTF:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x30
   \   <__C437> volatile __io _A_DDRF
   \                     _A_DDRF:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2e
   \   <__C443> volatile __io _A_PORTE
   \                     _A_PORTE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2d
   \   <__C446> volatile __io _A_DDRE
   \                     _A_DDRE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2c
   \   <__C449> volatile __io _A_PINE
   \                     _A_PINE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2a
   \   <__C455> volatile __io _A_DDRD
   \                     _A_DDRD:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x27
   \   <__C464> volatile __io _A_DDRC
   \                     _A_DDRC:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x25
   \   <__C470> volatile __io _A_PORTB
   \                     _A_PORTB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x24
   \   <__C473> volatile __io _A_DDRB
   \                     _A_DDRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x21
   \   <__C482> volatile __io _A_DDRA
   \                     _A_DDRA:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char count
   \                     count:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char volatile count_bod
   \                     count_bod:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char volatile t_led_on
   \                     t_led_on:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char R[28]
   \                     R:
   \   00000000                      DS8 28

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char Z[28]
   \                     `Z`:
   \   00000000                      DS8 28

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char F[28]
   \                     F:
   \   00000000                      DS8 28
      8          #include <math.h>     
      9          /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
     10          /*                                                                                                          */
     11          /*                                        Главная функция программы                                         */
     12          /*                                                                                                          */
     13          /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

   \                                 In  segment CODE, align 2, keep-with-next
     14          void main( void )
   \                     main:
     15          {
   \   00000000   ........           CALL    ?PROLOGUE8_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
     16            // задание интервала сброса WDT: 
     17            __watchdog_reset();                          // WDTCSR = WDIF WDIE WDP3 WDCE WDE WDP2 WDP1 WDP0 (XXXX XXXX)
   \   00000004   95A8               WDR
     18            WDTCSR |= (1<<WDCE) | (1<<WDE);              // разрешение настройки/системного сброса WDT      (XXX1 1XXX)
   \   00000006   9100....           LDS     R16, _A_WDTCSR
   \   0000000A   6108               ORI     R16, 0x18
   \   0000000C   9300....           STS     _A_WDTCSR, R16
     19            WDTCSR  = (1<<WDE)  | (1<<WDP3);             // установка тайм-аута = 512K циклов (~ 4.0 с)     (0010 1000)  
   \   00000010   E208               LDI     R16, 40
   \   00000012   9300....           STS     _A_WDTCSR, R16
     20            
     21            // инициализация портов:
     22            DDRA = (1<<IN1_01)|(1<<IN1_02)|(1<<IN1_03)|(1<<IN1_04)|(1<<IN1_05)|(1<<IN1_06)|(1<<IN1_07)|(1<<IN1_08); // выходы
   \   00000016   EF0F               LDI     R16, 255
   \   00000018   B901               OUT     0x01, R16
     23            
     24            PORTB = (1<<IN_SS0)|(1<<IN_SS1)|(1<<IN_SS2); // 1 на выходе
   \   0000001A   E301               LDI     R16, 49
   \   0000001C   B905               OUT     0x05, R16
     25            DDRB = (1<<IN_SS0)|(1<<IN_SCK)|(1<<IN_MOSI)|(1<<IN_SS1)|(1<<IN_SS2)|(1<<IN_LE); // выходы
   \   0000001E   E707               LDI     R16, 119
   \   00000020   B904               OUT     0x04, R16
     26            
     27            DDRC = (1<<IN1_09)|(1<<IN1_10)|(1<<IN1_11)|(1<<IN1_12)|(1<<IN1_13)|(1<<IN1_14)|(1<<IN1_15)|(1<<IN1_16); // выходы
   \   00000022   EF0F               LDI     R16, 255
   \   00000024   B907               OUT     0x07, R16
     28          
     29            DDRD = (1<<IN2_01)|(1<<IN2_02)|(1<<IN2_03)|(1<<IN2_04)|(1<<IN2_05)|(1<<IN2_06)|(1<<IN2_07)|(1<<IN2_08); // выходы
   \   00000026   EF0F               LDI     R16, 255
   \   00000028   B90A               OUT     0x0A, R16
     30          
     31            PORTE = (1<<RX)|(1<<TX); // подтяжка на питание или 1 на выходе
   \   0000002A   E003               LDI     R16, 3
   \   0000002C   B90E               OUT     0x0E, R16
     32            DDRE = (1<<TX)|(1<<ADLIN1_D0)|(1<<ADLIN1_D1)|(1<<ADLIN1_D2)|(1<<ADLIN1_D3)|(1<<ADLIN1_D4)|(1<<ADLIN1_D5); // выходы
   \   0000002E   EF0E               LDI     R16, 254
   \   00000030   B90D               OUT     0x0D, R16
     33          
     34            DDRF = (1<<ADLIN1_D6)|(1<<ADLIN2_D0)|(1<<ADLIN2_D1)|(1<<ADLIN2_D2)|(1<<ADLIN2_D3)|(1<<ADLIN2_D4)|(1<<ADLIN2_D5)|(1<<ADLIN2_D6); // выходы
   \   00000032   EF0F               LDI     R16, 255
   \   00000034   BB00               OUT     0x10, R16
     35            
     36            PORTG = (1<<LED); // 1 на выходе
   \   00000036   E200               LDI     R16, 32
   \   00000038   BB04               OUT     0x14, R16
     37            DDRG = (1<<IN4_09)|(1<<IN4_10)|(1<<IN4_11)|(1<<IN4_12)|(1<<IN4_13)|(1<<LED); // выходы
   \   0000003A   E30F               LDI     R16, 63
   \   0000003C   BB03               OUT     0x13, R16
     38            
     39            DDRH = (1<<IN2_09)|(1<<IN2_10)|(1<<IN2_11)|(1<<IN2_12)|(1<<IN2_13)|(1<<IN2_14)|(1<<IN2_15)|(1<<IN2_16); // выходы
   \   0000003E   EF0F               LDI     R16, 255
   \   00000040   9300....           STS     _A_DDRH, R16
     40            
     41            DDRJ = (1<<IN3_01)|(1<<IN3_02)|(1<<IN3_03)|(1<<IN3_04)|(1<<IN3_05)|(1<<IN3_06)|(1<<IN3_07)|(1<<IN3_08); // выходы
   \   00000044   EF0F               LDI     R16, 255
   \   00000046   9300....           STS     _A_DDRJ, R16
     42          
     43            DDRK = (1<<IN3_09)|(1<<IN3_10)|(1<<IN3_11)|(1<<IN3_12)|(1<<IN3_13)|(1<<IN3_14)|(1<<IN3_15)|(1<<IN3_16); // выходы
   \   0000004A   EF0F               LDI     R16, 255
   \   0000004C   9300....           STS     _A_DDRK, R16
     44          
     45            DDRL = (1<<IN4_01)|(1<<IN4_02)|(1<<IN4_03)|(1<<IN4_04)|(1<<IN4_05)|(1<<IN4_06)|(1<<IN4_07)|(1<<IN4_08); // выходы
   \   00000050   EF0F               LDI     R16, 255
   \   00000052   9300....           STS     _A_DDRL, R16
     46          
     47            count_bod = 1;                                  // минимум 1 прерывание
   \   00000056   E001               LDI     R16, 1
   \   00000058   9300....           STS     count_bod, R16
     48            t_led_on  = 0;                                  // время индикации
   \   0000005C   E000               LDI     R16, 0
   \   0000005E   9300....           STS     t_led_on, R16
     49            count     = 0;
   \   00000062   E000               LDI     R16, 0
   \   00000064   9300....           STS     count, R16
     50            
     51            __watchdog_reset();                             // 1-й "простой" cброс сторожевого таймера
   \   00000068   95A8               WDR
     52            __enable_interrupt();                           // прерывания разрешаем
   \   0000006A   9478               SEI
     53            
     54            // инициализация USART (2400):
     55            UCSR0A = 0x00;                             // запрет настроек USART на время установки скорости передачи
   \   0000006C   E000               LDI     R16, 0
   \   0000006E   9300....           STS     _A_UCSR0A, R16
     56            UCSR0B = 0x00;                             
   \   00000072   E000               LDI     R16, 0
   \   00000074   9300....           STS     _A_UCSR0B, R16
     57            UCSR0C = 0x06;                             // размер слова данных 8 бит
   \   00000078   E006               LDI     R16, 6
   \   0000007A   9300....           STS     _A_UCSR0C, R16
     58            UBRR0L = UBBR_2K4L;                        // задание скорости 2400
   \   0000007E   E90F               LDI     R16, 159
   \   00000080   9300....           STS     _A_UBRR0, R16
     59            UBRR0H = UBBR_2K4H;   
   \   00000084   E001               LDI     R16, 1
   \   00000086   930000C5           STS     197, R16
     60            UCSR0B = 0x08;                             // разрешение передачи (TXENn = 1)
   \   0000008A   E008               LDI     R16, 8
   \   0000008C   9300....           STS     _A_UCSR0B, R16
     61          
     62            // инициализация Т/С0:
     63            TCCR0B = 0x00;                             // останов Т/С0
   \   00000090   E000               LDI     R16, 0
   \   00000092   BD05               OUT     0x25, R16
     64            TCNT0  = RELOAD_TIM0;                      // нач. знач-е
   \   00000094   E908               LDI     R16, 152
   \   00000096   BD06               OUT     0x26, R16
     65            TCCR0A = 0x00;
   \   00000098   E000               LDI     R16, 0
   \   0000009A   BD04               OUT     0x24, R16
     66            TCCR0B = START_TIM0;                       // таймер запускаем
   \   0000009C   E004               LDI     R16, 4
   \   0000009E   BD05               OUT     0x25, R16
     67            TIMSK0 = 0x01;                             // Т/С0 <- источник прерываний
   \   000000A0   E001               LDI     R16, 1
   \   000000A2   9300....           STS     _A_TIMSK0, R16
     68              
     69            SPI_MasterInit();                          // инициализация SPI в режиме Master
   \   000000A6   ....               RCALL   SPI_MasterInit
     70          //////////////////////////////////////////////////////////////////////////////////////////////////////////////
     71                    
     72                                             //Организация работы линии обмена                   
     73                    
     74          //////////////////////////////////////////////////////////////////////////////////////////////////////////////
     75          /*
     76            Перед началом передачи пакета данных всегда есть синхропауза (логическая 1). Это нужно для безошибочной работы
     77            по линии, т.к. система асинхронная и ведомое устройство может включиться не одновременно с ведущим устройством. 
     78            Даже если устройство включится уже после начала передачи ведущим, оно примет данные только после "полной" 
     79            синхропаузы, которую будет ожидать. Длина синхропаузы больше, чем длина одного слова данных.
     80            Применение асинхронной системы позволяет использовать простой канал связи, который гораздо дешевле, чем при 
     81            синхронной системе. 
     82          */    
     83            for (;;)
     84            {     
     85              UCSR0B &= ~(1<<RXEN0);                   // отключение приемника USART
   \                     ??main_0:
   \   000000A8   910000C1           LDS     R16, 193
   \   000000AC   7E0F               ANDI    R16, 0xEF
   \   000000AE   930000C1           STS     193, R16
     86              count_bod = CBOD;                        // счетчик БОД
   \   000000B2   E004               LDI     R16, 4
   \   000000B4   9300....           STS     count_bod, R16
     87          
     88              do
     89              {
     90                if (!(PINE & (1<<RX))) count_bod = CBOD;
   \                     ??main_1:
   \   000000B8   9960               SBIC    0x0C, 0x00
   \   000000BA   C003               RJMP    ??main_2
   \   000000BC   E004               LDI     R16, 4
   \   000000BE   9300....           STS     count_bod, R16
     91              } while (count_bod);                     // ожидание СИНХРО-ПАУЗЫ (всегда только перед командой)
   \                     ??main_2:
   \   000000C2   9100....           LDS     R16, count_bod
   \   000000C6   2300               TST     R16
   \   000000C8   F7B9               BRNE    ??main_1
     92          /*
     93              Выполнять присваивание count_bod = CBOD = 4, если RX = 0, пока count_bod - истина. Если же в течение четырёх
     94              периодов переполнения таймера0 с частотой 600 Гц, т.е. 6.7 мс, будет выполнено условие RX = 1, тогда
     95              программа уменьшит значение count_bod до нуля, условие while (count_bod) станет ложным и произойдёт 
     96              выход из цикла do/while. Только теперь устройство включится на приём. Таким образом, значение синхропаузы 
     97              составляет 6.7 мс. Начало приёма происходит при обнаружении старт-бита (логический 0).
     98          */     
     99              // приём данных по UART:
    100          /*
    101              Вперёд старший регистр. Вперёд старший байт.
    102          */
    103              UCSR0B |= (1<<RXEN0);                    // включение приемника USART
   \   000000CA   910000C1           LDS     R16, 193
   \   000000CE   6100               ORI     R16, 0x10
   \   000000D0   930000C1           STS     193, R16
    104               
    105              for(int i=27; i>=0; i--)                 // приём семи 4-х байтовых регистров по UART
   \   000000D4   E10B               LDI     R16, 27
   \   000000D6   E010               LDI     R17, 0
   \                     ??main_3:
   \   000000D8   2311               TST     R17
   \   000000DA   F072               BRMI    ??main_4
    106              {
    107                while (!(UCSR0A & (1<<RXC0)));         // ждем завершение приема байта
   \                     ??main_5:
   \   000000DC   9120....           LDS     R18, _A_UCSR0A
   \   000000E0   2F32               MOV     R19, R18
   \   000000E2   FF37               SBRS    R19, 7
   \   000000E4   CFFB               RJMP    ??main_5
    108                R[i] = UDR0;                           // R6_4, R6_3,...,R6_1,...R0_1
   \   000000E6   9120....           LDS     R18, _A_UDR0
   \   000000EA   01F8               MOVW    R31:R30, R17:R16
   \   000000EC   ....               SUBI    R30, LOW((-(R) & 0xFFFF))
   \   000000EE   ....               SBCI    R31, (-(R) & 0xFFFF) >> 8
   \   000000F0   8320               ST      Z, R18
    109              }
   \   000000F2   5001               SUBI    R16, 1
   \   000000F4   4010               SBCI    R17, 0
   \   000000F6   CFF0               RJMP    ??main_3
    110          
    111              t_led_on  = T_LED_ON;                    // время подсвечивания
   \                     ??main_4:
   \   000000F8   E302               LDI     R16, 50
   \   000000FA   9300....           STS     t_led_on, R16
    112              LED_ON;   
   \   000000FE   98A5               CBI     0x14, 0x05
    113                
    114              unsigned char ONE, TWO;
    115                
    116              // передача данных по SPI на hmc1044lp3 Tfcf:
    117          /*
    118              D8D7D6D5D4D3D2D1 D0A3A2A1A0CA2CA1CA0 - 2 байта для передачи по SPI на hmc1044lp3, где
    119              D8D7D6D5D4D3D2D1D0 - данные;
    120              A3A2A1A0 - адрес регистра = 01h;
    121              CA2CA1CA0 - адрес чипа = 110b.
    122          */
    123              ClearBit(PORTB, IN_SS0);                   // деактивация ведомого ADF4350
   \   00000100   9828               CBI     0x05, 0x00
    124                
    125              ONE = R[27];   // xxxx 1111 
   \   00000102   9100....           LDS     R16, (R + 27)
   \   00000106   2F80               MOV     R24, R16
    126              ONE>>=1;       // xxxx x111
   \   00000108   9586               LSR     R24
    127              ONE&=0x7;      // 0000 0111 первый байт - данные без D0
   \   0000010A   7087               ANDI    R24, 0x07
    128                
    129              TWO = R[27];   // xxxx 1111
   \   0000010C   9100....           LDS     R16, (R + 27)
   \   00000110   2FA0               MOV     R26, R16
    130              TWO&=0x1;      // 0000 0001   
   \   00000112   2F0A               MOV     R16, R26
   \   00000114   2FA0               MOV     R26, R16
   \   00000116   70A1               ANDI    R26, 0x01
    131              TWO<<=7;       // 1000 0000
   \   00000118   2F0A               MOV     R16, R26
   \   0000011A   FB00               BST     R16, 0
   \   0000011C   E0A0               LDI     R26, 0
   \   0000011E   F9A7               BLD     R26, 7
    132              TWO+=0x0E;     // 1000 1110 второй байт - D0, адреса регистра и чипа 
   \   00000120   5FA2               SUBI    R26, 242
    133                
    134              ClearBit(PORTB, IN_SS1);                 // активация ведомого hmc1044lp3 Tfcf
   \   00000122   982C               CBI     0x05, 0x04
    135              SPI_Write(ONE);                          // загрузка ONE по SPI
   \   00000124   2F08               MOV     R16, R24
   \   00000126   ....               RCALL   SPI_Write
    136              SPI_Write(TWO);                          // загрузка TWO по SPI 
   \   00000128   2F0A               MOV     R16, R26
   \   0000012A   ....               RCALL   SPI_Write
    137              SetBit(PORTB, IN_SS1);                   // деактивация ведомого hmc1044lp3 Tfcf
   \   0000012C   9A2C               SBI     0x05, 0x04
    138                
    139              SetBit(PORTB, IN_SS0);                   // активация ведомого ADF4350
   \   0000012E   9A28               SBI     0x05, 0x00
    140           
    141              // передача данных по SPI на hmc1044lp3 Rfcf:
    142          /*
    143              D8D7D6D5D4D3D2D1 D0A3A2A1A0CA2CA1CA0 - 2 байта для передачи по SPI на hmc1044lp3, где
    144              D8D7D6D5D4D3D2D1D0 - данные;
    145              A3A2A1A0 - адрес регистра = 01h;
    146              CA2CA1CA0 - адрес чипа = 110b.
    147          */     
    148              ClearBit(PORTB, IN_SS0);                 // деактивация ведомого ADF4350
   \   00000130   9828               CBI     0x05, 0x00
    149                
    150              ONE = R[26];   // xxxx 1111
   \   00000132   9100....           LDS     R16, (R + 26)
   \   00000136   2F80               MOV     R24, R16
    151              ONE>>=1;       // xxxx x111
   \   00000138   9586               LSR     R24
    152              ONE&=0x7;      // 0000 0111 первый байт - данные без D0
   \   0000013A   7087               ANDI    R24, 0x07
    153                
    154              TWO = R[26];   // xxxx 1111
   \   0000013C   9100....           LDS     R16, (R + 26)
   \   00000140   2FA0               MOV     R26, R16
    155              TWO&=0x1;      // 0000 0001      
   \   00000142   2F0A               MOV     R16, R26
   \   00000144   2FA0               MOV     R26, R16
   \   00000146   70A1               ANDI    R26, 0x01
    156              TWO<<=7;       // 1000 0000
   \   00000148   2F0A               MOV     R16, R26
   \   0000014A   FB00               BST     R16, 0
   \   0000014C   E0A0               LDI     R26, 0
   \   0000014E   F9A7               BLD     R26, 7
    157              TWO+=0x0E;     // 1000 1110 второй байт - D0, адреса регистра и чипа
   \   00000150   5FA2               SUBI    R26, 242
    158                
    159              ClearBit(PORTB, IN_SS2);                 // активация ведомого hmc1044lp3 Rfcf
   \   00000152   982D               CBI     0x05, 0x05
    160              SPI_Write(ONE);                          // загрузка ONE по SPI
   \   00000154   2F08               MOV     R16, R24
   \   00000156   ....               RCALL   SPI_Write
    161              SPI_Write(TWO);                          // загрузка TWO по SPI 
   \   00000158   2F0A               MOV     R16, R26
   \   0000015A   ....               RCALL   SPI_Write
    162              SetBit(PORTB, IN_SS2);                   // деактивация ведомого hmc1044lp3 Rfcf
   \   0000015C   9A2D               SBI     0x05, 0x05
    163                
    164              SetBit(PORTB, IN_SS0);                   // активация ведомого ADF4350
   \   0000015E   9A28               SBI     0x05, 0x00
    165               
    166              // передача данных по SPI на ADF4350:
    167              for(int j=0; j<=5; j++)
   \   00000160   2444               CLR     R4
   \   00000162   2455               CLR     R5
   \                     ??main_6:
   \   00000164   E006               LDI     R16, 6
   \   00000166   1640               CP      R4, R16
   \   00000168   E000               LDI     R16, 0
   \   0000016A   0650               CPC     R5, R16
   \   0000016C   F53C               BRGE    ??main_7
    168              {  
    169                for(int i=(23-4*j); i>=(20-4*j); i--)  
   \   0000016E   E127               LDI     R18, 23
   \   00000170   E030               LDI     R19, 0
   \   00000172   0182               MOVW    R17:R16, R5:R4
   \   00000174   0F00               LSL     R16
   \   00000176   1F11               ROL     R17
   \   00000178   0F00               LSL     R16
   \   0000017A   1F11               ROL     R17
   \   0000017C   1B20               SUB     R18, R16
   \   0000017E   0B31               SBC     R19, R17
   \   00000180   0139               MOVW    R7:R6, R19:R18
   \                     ??main_8:
   \   00000182   E124               LDI     R18, 20
   \   00000184   E030               LDI     R19, 0
   \   00000186   0182               MOVW    R17:R16, R5:R4
   \   00000188   0F00               LSL     R16
   \   0000018A   1F11               ROL     R17
   \   0000018C   0F00               LSL     R16
   \   0000018E   1F11               ROL     R17
   \   00000190   1B20               SUB     R18, R16
   \   00000192   0B31               SBC     R19, R17
   \   00000194   1662               CP      R6, R18
   \   00000196   0673               CPC     R7, R19
   \   00000198   F054               BRLT    ??main_9
    170                { 
    171                  SPI_Write(R[i]);                     // загрузка R5_4, R5_3,...,R5_1,...R0_1 по SPI в 32-разрядный буферный регистр
   \   0000019A   01F3               MOVW    R31:R30, R7:R6
   \   0000019C   ....               SUBI    R30, LOW((-(R) & 0xFFFF))
   \   0000019E   ....               SBCI    R31, (-(R) & 0xFFFF) >> 8
   \   000001A0   8100               LD      R16, Z
   \   000001A2   ....               RCALL   SPI_Write
    172                }
   \   000001A4   EF0F               LDI     R16, 255
   \   000001A6   0E60               ADD     R6, R16
   \   000001A8   EF0F               LDI     R16, 255
   \   000001AA   1E70               ADC     R7, R16
   \   000001AC   CFEA               RJMP    ??main_8
    173                
    174                SetBit(PORTB, IN_LE);                  // загрузка данных, хранящихся в регистре сдвига, в один из регистров-защёлок
   \                     ??main_9:
   \   000001AE   9A2E               SBI     0x05, 0x06
    175                ClearBit(PORTB, IN_LE);
   \   000001B0   982E               CBI     0x05, 0x06
    176              }
   \   000001B2   E001               LDI     R16, 1
   \   000001B4   0E40               ADD     R4, R16
   \   000001B6   E000               LDI     R16, 0
   \   000001B8   1E50               ADC     R5, R16
   \   000001BA   CFD4               RJMP    ??main_6
    177                      
    178              unsigned char temp;
    179                
    180              // передача данных в параллельный порт на ADL5240 Tаf:
    181              temp = R[25];  // xx1x xxxx
   \                     ??main_7:
   \   000001BC   9100....           LDS     R16, (R + 25)
   \   000001C0   2F90               MOV     R25, R16
    182              temp>>=5;      // xxxx xxx1
   \   000001C2   9592               SWAP    R25
   \   000001C4   709F               ANDI    R25, 0x0F
   \   000001C6   9596               LSR     R25
    183              temp&=1;       // 0000 0001
   \   000001C8   2F09               MOV     R16, R25
   \   000001CA   2F90               MOV     R25, R16
   \   000001CC   7091               ANDI    R25, 0x01
    184              PORTE |= (temp<<ADLIN1_D1);
   \   000001CE   2F09               MOV     R16, R25
   \   000001D0   0F00               LSL     R16
   \   000001D2   0F00               LSL     R16
   \   000001D4   0F00               LSL     R16
   \   000001D6   B11E               IN      R17, 0x0E
   \   000001D8   2B10               OR      R17, R16
   \   000001DA   B91E               OUT     0x0E, R17
    185                
    186              temp = R[25];  // xxx1 xxxx
   \   000001DC   9100....           LDS     R16, (R + 25)
   \   000001E0   2F90               MOV     R25, R16
    187              temp>>=4;      // xxxx xxx1
   \   000001E2   9592               SWAP    R25
   \   000001E4   709F               ANDI    R25, 0x0F
    188              temp&=1;       // 0000 0001
   \   000001E6   2F09               MOV     R16, R25
   \   000001E8   2F90               MOV     R25, R16
   \   000001EA   7091               ANDI    R25, 0x01
    189              PORTE |= (temp<<ADLIN1_D2);
   \   000001EC   2F09               MOV     R16, R25
   \   000001EE   9502               SWAP    R16
   \   000001F0   7F00               ANDI    R16, 0xF0
   \   000001F2   B11E               IN      R17, 0x0E
   \   000001F4   2B10               OR      R17, R16
   \   000001F6   B91E               OUT     0x0E, R17
    190                
    191              temp = R[25];  // xxxx 1xxx
   \   000001F8   9100....           LDS     R16, (R + 25)
   \   000001FC   2F90               MOV     R25, R16
    192              temp>>=3;      // xxxx xxx1
   \   000001FE   9596               LSR     R25
   \   00000200   9596               LSR     R25
   \   00000202   9596               LSR     R25
    193              temp&=1;       // 0000 0001
   \   00000204   2F09               MOV     R16, R25
   \   00000206   2F90               MOV     R25, R16
   \   00000208   7091               ANDI    R25, 0x01
    194              PORTE |= (temp<<ADLIN1_D3);      
   \   0000020A   2F09               MOV     R16, R25
   \   0000020C   9502               SWAP    R16
   \   0000020E   7F00               ANDI    R16, 0xF0
   \   00000210   0F00               LSL     R16
   \   00000212   B11E               IN      R17, 0x0E
   \   00000214   2B10               OR      R17, R16
   \   00000216   B91E               OUT     0x0E, R17
    195                
    196              temp = R[25];  // xxxx x1xx
   \   00000218   9100....           LDS     R16, (R + 25)
   \   0000021C   2F90               MOV     R25, R16
    197              temp>>=2;      // xxxx xxx1
   \   0000021E   9596               LSR     R25
   \   00000220   9596               LSR     R25
    198              temp&=1;       // 0000 0001
   \   00000222   2F09               MOV     R16, R25
   \   00000224   2F90               MOV     R25, R16
   \   00000226   7091               ANDI    R25, 0x01
    199              PORTE |= (temp<<ADLIN1_D4); 
   \   00000228   E400               LDI     R16, 64
   \   0000022A   9F90               MUL     R25, R16
   \   0000022C   B10E               IN      R16, 0x0E
   \   0000022E   2900               OR      R16, R0
   \   00000230   B90E               OUT     0x0E, R16
    200                
    201              temp = R[25];  // xxxx xx1x
   \   00000232   9100....           LDS     R16, (R + 25)
   \   00000236   2F90               MOV     R25, R16
    202              temp>>=1;      // xxxx xxx1
   \   00000238   9596               LSR     R25
    203              temp&=1;       // 0000 0001
   \   0000023A   2F09               MOV     R16, R25
   \   0000023C   2F90               MOV     R25, R16
   \   0000023E   7091               ANDI    R25, 0x01
    204              PORTE |= (temp<<ADLIN1_D5);      
   \   00000240   2F09               MOV     R16, R25
   \   00000242   FB00               BST     R16, 0
   \   00000244   E000               LDI     R16, 0
   \   00000246   F907               BLD     R16, 7
   \   00000248   B11E               IN      R17, 0x0E
   \   0000024A   2B10               OR      R17, R16
   \   0000024C   B91E               OUT     0x0E, R17
    205                
    206              temp = R[25];  // xxxx xxx1
   \   0000024E   9100....           LDS     R16, (R + 25)
   \   00000252   2F90               MOV     R25, R16
    207              temp&=1;       // 0000 0001
   \   00000254   2F09               MOV     R16, R25
   \   00000256   2F90               MOV     R25, R16
   \   00000258   7091               ANDI    R25, 0x01
    208              PORTF |= (temp<<ADLIN1_D6);  
   \   0000025A   B301               IN      R16, 0x11
   \   0000025C   2B09               OR      R16, R25
   \   0000025E   BB01               OUT     0x11, R16
    209                
    210              // передача данных в параллельный порт на ADL5240 Rаf:
    211              temp = R[24];  // xx1x xxxx
   \   00000260   9100....           LDS     R16, (R + 24)
   \   00000264   2F90               MOV     R25, R16
    212              temp>>=5;      // xxxx xxx1
   \   00000266   9592               SWAP    R25
   \   00000268   709F               ANDI    R25, 0x0F
   \   0000026A   9596               LSR     R25
    213              temp&=1;       // 0000 0001
   \   0000026C   2F09               MOV     R16, R25
   \   0000026E   2F90               MOV     R25, R16
   \   00000270   7091               ANDI    R25, 0x01
    214              PORTF |= (temp<<ADLIN2_D1);
   \   00000272   2F09               MOV     R16, R25
   \   00000274   0F00               LSL     R16
   \   00000276   0F00               LSL     R16
   \   00000278   B311               IN      R17, 0x11
   \   0000027A   2B10               OR      R17, R16
   \   0000027C   BB11               OUT     0x11, R17
    215                
    216              temp = R[24];  // xxx1 xxxx
   \   0000027E   9100....           LDS     R16, (R + 24)
   \   00000282   2F90               MOV     R25, R16
    217              temp>>=4;      // xxxx xxx1
   \   00000284   9592               SWAP    R25
   \   00000286   709F               ANDI    R25, 0x0F
    218              temp&=1;       // 0000 0001
   \   00000288   2F09               MOV     R16, R25
   \   0000028A   2F90               MOV     R25, R16
   \   0000028C   7091               ANDI    R25, 0x01
    219              PORTF |= (temp<<ADLIN2_D2);
   \   0000028E   2F09               MOV     R16, R25
   \   00000290   0F00               LSL     R16
   \   00000292   0F00               LSL     R16
   \   00000294   0F00               LSL     R16
   \   00000296   B311               IN      R17, 0x11
   \   00000298   2B10               OR      R17, R16
   \   0000029A   BB11               OUT     0x11, R17
    220                
    221              temp = R[24];  // xxxx 1xxx
   \   0000029C   9100....           LDS     R16, (R + 24)
   \   000002A0   2F90               MOV     R25, R16
    222              temp>>=3;      // xxxx xxx1
   \   000002A2   9596               LSR     R25
   \   000002A4   9596               LSR     R25
   \   000002A6   9596               LSR     R25
    223              temp&=1;       // 0000 0001
   \   000002A8   2F09               MOV     R16, R25
   \   000002AA   2F90               MOV     R25, R16
   \   000002AC   7091               ANDI    R25, 0x01
    224              PORTF |= (temp<<ADLIN2_D3);      
   \   000002AE   2F09               MOV     R16, R25
   \   000002B0   9502               SWAP    R16
   \   000002B2   7F00               ANDI    R16, 0xF0
   \   000002B4   B311               IN      R17, 0x11
   \   000002B6   2B10               OR      R17, R16
   \   000002B8   BB11               OUT     0x11, R17
    225                
    226              temp = R[24];  // xxxx x1xx
   \   000002BA   9100....           LDS     R16, (R + 24)
   \   000002BE   2F90               MOV     R25, R16
    227              temp>>=2;      // xxxx xxx1
   \   000002C0   9596               LSR     R25
   \   000002C2   9596               LSR     R25
    228              temp&=1;       // 0000 0001
   \   000002C4   2F09               MOV     R16, R25
   \   000002C6   2F90               MOV     R25, R16
   \   000002C8   7091               ANDI    R25, 0x01
    229              PORTF |= (temp<<ADLIN2_D4); 
   \   000002CA   2F09               MOV     R16, R25
   \   000002CC   9502               SWAP    R16
   \   000002CE   7F00               ANDI    R16, 0xF0
   \   000002D0   0F00               LSL     R16
   \   000002D2   B311               IN      R17, 0x11
   \   000002D4   2B10               OR      R17, R16
   \   000002D6   BB11               OUT     0x11, R17
    230                
    231              temp = R[24];  // xxxx xx1x
   \   000002D8   9100....           LDS     R16, (R + 24)
   \   000002DC   2F90               MOV     R25, R16
    232              temp>>=1;      // xxxx xxx1
   \   000002DE   9596               LSR     R25
    233              temp&=1;       // 0000 0001
   \   000002E0   2F09               MOV     R16, R25
   \   000002E2   2F90               MOV     R25, R16
   \   000002E4   7091               ANDI    R25, 0x01
    234              PORTF |= (temp<<ADLIN2_D5);      
   \   000002E6   E400               LDI     R16, 64
   \   000002E8   9F90               MUL     R25, R16
   \   000002EA   B301               IN      R16, 0x11
   \   000002EC   2900               OR      R16, R0
   \   000002EE   BB01               OUT     0x11, R16
    235                
    236              temp = R[24];  // xxxx xxx1
   \   000002F0   9100....           LDS     R16, (R + 24)
   \   000002F4   2F90               MOV     R25, R16
    237              temp&=1;       // 0000 0001
   \   000002F6   2F09               MOV     R16, R25
   \   000002F8   2F90               MOV     R25, R16
   \   000002FA   7091               ANDI    R25, 0x01
    238              PORTF |= (temp<<ADLIN2_D6);      
   \   000002FC   2F09               MOV     R16, R25
   \   000002FE   FB00               BST     R16, 0
   \   00000300   E000               LDI     R16, 0
   \   00000302   F907               BLD     R16, 7
   \   00000304   B311               IN      R17, 0x11
   \   00000306   2B10               OR      R17, R16
   \   00000308   BB11               OUT     0x11, R17
    239          
    240              __watchdog_reset();
   \   0000030A   95A8               WDR
   \   0000030C   CECD               RJMP    ??main_0
   \   0000030E                      REQUIRE _A_DDRL
   \   0000030E                      REQUIRE _A_DDRK
   \   0000030E                      REQUIRE _A_DDRJ
   \   0000030E                      REQUIRE _A_DDRH
   \   0000030E                      REQUIRE _A_UDR0
   \   0000030E                      REQUIRE _A_UBRR0
   \   0000030E                      REQUIRE _A_UCSR0C
   \   0000030E                      REQUIRE _A_UCSR0B
   \   0000030E                      REQUIRE _A_UCSR0A
   \   0000030E                      REQUIRE _A_TIMSK0
   \   0000030E                      REQUIRE _A_WDTCSR
   \   0000030E                      REQUIRE _A_TCNT0
   \   0000030E                      REQUIRE _A_TCCR0B
   \   0000030E                      REQUIRE _A_TCCR0A
   \   0000030E                      REQUIRE _A_PORTG
   \   0000030E                      REQUIRE _A_DDRG
   \   0000030E                      REQUIRE _A_PORTF
   \   0000030E                      REQUIRE _A_DDRF
   \   0000030E                      REQUIRE _A_PORTE
   \   0000030E                      REQUIRE _A_DDRE
   \   0000030E                      REQUIRE _A_PINE
   \   0000030E                      REQUIRE _A_DDRD
   \   0000030E                      REQUIRE _A_DDRC
   \   0000030E                      REQUIRE _A_PORTB
   \   0000030E                      REQUIRE _A_DDRB
   \   0000030E                      REQUIRE _A_DDRA
    241            }
    242          }
    243          /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
    244          /*                                                                                                          */
    245          /*                                               Подпрограммы                                               */
    246          /*                                                                                                          */
    247          /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
    248          #pragma vector=TIMER0_OVF_vect         // директива определяет вектор функции прерывания, описание которой следует за ней                 

   \                                 In  segment CODE, align 2, keep-with-next
    249          __interrupt void timer0_ovf_isr(void)  // функция прерывания по переполнению таймера0 
   \                     timer0_ovf_isr:
    250          {
   \   00000000   932A               ST      -Y, R18
   \   00000002   931A               ST      -Y, R17
   \   00000004   930A               ST      -Y, R16
   \   00000006   B71F               IN      R17, 0x3F
   \   00000008   B72B               IN      R18, 0x3B
    251            //TIMER0 has overflowed
    252            TCNT0  = RELOAD_TIM0;                // reload counter value
   \   0000000A   E908               LDI     R16, 152
   \   0000000C   BD06               OUT     0x26, R16
    253          
    254            if (count_bod)  count_bod--;
   \   0000000E   9100....           LDS     R16, count_bod
   \   00000012   2300               TST     R16
   \   00000014   F029               BREQ    ??timer0_ovf_isr_0
   \   00000016   9100....           LDS     R16, count_bod
   \   0000001A   950A               DEC     R16
   \   0000001C   9300....           STS     count_bod, R16
    255          
    256            if(t_led_on)  t_led_on--;            // время подсвечивания --
   \                     ??timer0_ovf_isr_0:
   \   00000020   9100....           LDS     R16, t_led_on
   \   00000024   2300               TST     R16
   \   00000026   F031               BREQ    ??timer0_ovf_isr_1
   \   00000028   9100....           LDS     R16, t_led_on
   \   0000002C   950A               DEC     R16
   \   0000002E   9300....           STS     t_led_on, R16
   \   00000032   C001               RJMP    ??timer0_ovf_isr_2
    257            else          LED_OFF;               // LED-OFF
   \                     ??timer0_ovf_isr_1:
   \   00000034   9AA5               SBI     0x14, 0x05
    258          /*
    259            Частота переполнения таймера0 SYSTEM_TICK выбрана 600 Гц. Поэтому период переполнения таймера0 Tovf 
    260            составляет 1.7 мс, а константа перезагрузки 'TIM0' составляет RELOAD_TIM0 = 152(0x98). Подпрограмма 
    261            обработки прерывания по переполнению таймера0 вызывается каждые 1.7 мс, заново загружает константу 
    262            перезагрузки 'TIM0' и каждый раз уменьшает значение count_bod и t_led_on на единицу, пока значение 
    263            count_bod > 0 и t_led_on > 0. 
    264            Время горения светодиода будет T_LED_ON*Tovf = 120*1.7мс = 0.2c.
    265          */
    266          }
   \                     ??timer0_ovf_isr_2:
   \   00000036   BF2B               OUT     0x3B, R18
   \   00000038   BF1F               OUT     0x3F, R17
   \   0000003A   9109               LD      R16, Y+
   \   0000003C   9119               LD      R17, Y+
   \   0000003E   9129               LD      R18, Y+
   \   00000040   9518               RETI
   \   00000042                      REQUIRE _A_TCNT0
   \   00000042                      REQUIRE _A_PORTG
    267          
    268          // Подпрограмма инициализации SPI в режиме Master

   \                                 In  segment CODE, align 2, keep-with-next
    269          void SPI_MasterInit(void)
   \                     SPI_MasterInit:
    270          {
    271          /* 
    272            - Разрешение SPI в режиме мастера,
    273            - CPOL = 1 - генерируются тактовые импульсы отрицательной полярности,
    274            - CPHA = 0 - обработка данных производится по переднему спадающему фронту импульсов сигнала SCK,
    275            - установка скорости обмена fck/128 
    276          */
    277            SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0)|(1<<CPOL);
   \   00000000   E50B               LDI     R16, 91
   \   00000002   BD0C               OUT     0x2C, R16
    278          }
   \   00000004   9508               RET
   \   00000006                      REQUIRE _A_SPCR
    279          
    280          // Подпрограмма записи по SPI

   \                                 In  segment CODE, align 2, keep-with-next
    281          void SPI_Write(unsigned char dataout)
   \                     SPI_Write:
    282          {
    283            // Запись байта в регист данных ведущего (инициализация передачи)
    284            SPDR = dataout;
   \   00000000   BD0E               OUT     0x2E, R16
    285            // Ожидание завершения передачи (пока бит SPIF не установлен)
    286            while(!(SPSR & (1<<SPIF)));
   \                     ??SPI_Write_0:
   \   00000002   B51D               IN      R17, 0x2D
   \   00000004   2F21               MOV     R18, R17
   \   00000006   FF27               SBRS    R18, 7
   \   00000008   CFFC               RJMP    ??SPI_Write_0
    287          }
   \   0000000A   9508               RET
   \   0000000C                      REQUIRE _A_SPDR
   \   0000000C                      REQUIRE _A_SPSR

   \                                 In  segment INTVEC, offset 0x5c, root
   \                     `??timer0_ovf_isr??INTVEC 92`:
   \   0000005C   ........           JMP     timer0_ovf_isr

   Maximum stack usage in bytes:

     Function            CSTACK RSTACK
     --------            ------ ------
     SPI_MasterInit          0      2
     SPI_Write               0      2
     main                    8      2
       -> SPI_MasterInit     8      2
       -> SPI_Write          8      2
       -> SPI_Write          8      2
       -> SPI_Write          8      2
       -> SPI_Write          8      2
       -> SPI_Write          8      2
     timer0_ovf_isr          3      2


   Segment part sizes:

     Function/Label              Bytes
     --------------              -----
     Title                         51
     _A_DDRL                        1
     _A_DDRK                        1
     _A_DDRJ                        1
     _A_DDRH                        1
     _A_UDR0                        1
     _A_UBRR0                       2
     _A_UCSR0C                      1
     _A_UCSR0B                      1
     _A_UCSR0A                      1
     _A_TIMSK0                      1
     _A_WDTCSR                      1
     _A_SPDR                        1
     _A_SPSR                        1
     _A_SPCR                        1
     _A_TCNT0                       1
     _A_TCCR0B                      1
     _A_TCCR0A                      1
     _A_PORTG                       1
     _A_DDRG                        1
     _A_PORTF                       1
     _A_DDRF                        1
     _A_PORTE                       1
     _A_DDRE                        1
     _A_PINE                        1
     _A_DDRD                        1
     _A_DDRC                        1
     _A_PORTB                       1
     _A_DDRB                        1
     _A_DDRA                        1
     count                          1
     count_bod                      1
     t_led_on                       1
     R                             28
     Z                             28
     F                             28
     main                         782
     timer0_ovf_isr                66
     SPI_MasterInit                 6
     SPI_Write                     12
     ??timer0_ovf_isr??INTVEC 92    4
      Others                        7

 
  30 bytes in segment ABSOLUTE
 866 bytes in segment CODE
   7 bytes in segment INITTAB
   4 bytes in segment INTVEC
  51 bytes in segment NEAR_F
  87 bytes in segment NEAR_Z
 
 917 bytes of CODE memory (+ 11 bytes shared)
  87 bytes of DATA memory (+ 30 bytes shared)

Errors: none
Warnings: none
