###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.50.0.50277/W32 for Atmel AVR    23/Oct/2013  17:53:19 #
# Copyright (C) 1996-2010 IAR Systems AB.                                     #
#                                                                             #
#    Source file  =  D:\_IAR projects\ADF4350_IAR_ver.1\ADF4350_02\main.c     #
#    Command line =  "D:\_IAR projects\ADF4350_IAR_ver.1\ADF4350_02\main.c"   #
#                    --cpu=m1280 -ms -o "D:\_IAR                              #
#                    projects\ADF4350_IAR_ver.1\ADF4350_02\Project\ADF4350_Re #
#                    lease\Obj\" -D NDEBUG -lCN "D:\_IAR                      #
#                    projects\ADF4350_IAR_ver.1\ADF4350_02\Project\ADF4350_Re #
#                    lease\List\" -y --initializers_in_flash -s2 --no_cse     #
#                    --no_inline --no_code_motion --no_cross_call             #
#                    --no_clustering --no_tbaa -DENABLE_BIT_DEFINITIONS -e    #
#                    -I "E:\Program Files\IAR Systems\Embedded Workbench      #
#                    5.4\avr\INC\" -I "E:\Program Files\IAR Systems\Embedded  #
#                    Workbench 5.4\avr\INC\CLIB\" --eeprom_size 4096          #
#    List file    =  D:\_IAR projects\ADF4350_IAR_ver.1\ADF4350_02\Project\AD #
#                    F4350_Release\List\main.lst                              #
#    Object file  =  D:\_IAR projects\ADF4350_IAR_ver.1\ADF4350_02\Project\AD #
#                    F4350_Release\Obj\main.r90                               #
#                                                                             #
#                                                                             #
###############################################################################

D:\_IAR projects\ADF4350_IAR_ver.1\ADF4350_02\main.c
      1          /************************************************************************************************************/
      2          /*                                                                                                          */
      3          /*                      Управляющая программа для ATmega1280 в проекте "Интерфейс ADF4350"                  */
      4          /*                                       Версия 1.2 (2013.10.22_10-55)                                      */
      5          /*                                                                                                          */
      6          /************************************************************************************************************/
      7          #include "main.h"

   \                                 In  segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash Title[51]
   \                     Title:
   \   00000000   444134463533       DC8 41H, 44H, 46H, 34H, 33H, 35H, 30H, 20H
   \              2030        
   \   00000008   202D69576564       DC8 2DH, 20H, 57H, 69H, 64H, 65H, 62H, 61H
   \              6162        
   \   00000010   646E53206E79       DC8 6EH, 64H, 20H, 53H, 79H, 6EH, 74H, 68H
   \              6874        
   \   00000018   73657A697265       DC8 65H, 73H, 69H, 7AH, 65H, 72H, 20H, 77H
   \              7720        
   \   00000020   746920686E49       DC8 69H, 74H, 68H, 20H, 49H, 6EH, 74H, 65H
   \              6574        
   \   00000028   726774616465       DC8 67H, 72H, 61H, 74H, 65H, 64H, 20H, 56H
   \              5620        
   \   00000030   4F4300             DC8 43H, 4FH, 0

   \                                 In  segment ABSOLUTE, at 0x10a
   \   <__C51> volatile __ext_io _A_DDRL
   \                     _A_DDRL:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x107
   \   <__C60> volatile __ext_io _A_DDRK
   \                     _A_DDRK:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x104
   \   <__C69> volatile __ext_io _A_DDRJ
   \                     _A_DDRJ:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x101
   \   <__C78> volatile __ext_io _A_DDRH
   \                     _A_DDRH:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc6
   \   <__C115> volatile __io _A_UDR0
   \                     _A_UDR0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc4
   \   <__C119> volatile __io _A_UBRR0
   \                     _A_UBRR0:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0xc2
   \   <__C123> volatile __io _A_UCSR0C
   \                     _A_UCSR0C:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc1
   \   <__C126> volatile __io _A_UCSR0B
   \                     _A_UCSR0B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc0
   \   <__C129> volatile __io _A_UCSR0A
   \                     _A_UCSR0A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x6e
   \   <__C293> volatile __io _A_TIMSK0
   \                     _A_TIMSK0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x60
   \   <__C325> volatile __io _A_WDTCSR
   \                     _A_WDTCSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x4e
   \   <__C359> volatile __io _A_SPDR
   \                     _A_SPDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x4d
   \   <__C362> volatile __io _A_SPSR
   \                     _A_SPSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x4c
   \   <__C365> volatile __io _A_SPCR
   \                     _A_SPCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x46
   \   <__C375> volatile __io _A_TCNT0
   \                     _A_TCNT0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x45
   \   <__C378> volatile __io _A_TCCR0B
   \                     _A_TCCR0B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x44
   \   <__C381> volatile __io _A_TCCR0A
   \                     _A_TCCR0A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x34
   \   <__C425> volatile __io _A_PORTG
   \                     _A_PORTG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x33
   \   <__C428> volatile __io _A_DDRG
   \                     _A_DDRG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x31
   \   <__C434> volatile __io _A_PORTF
   \                     _A_PORTF:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x30
   \   <__C437> volatile __io _A_DDRF
   \                     _A_DDRF:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2e
   \   <__C443> volatile __io _A_PORTE
   \                     _A_PORTE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2d
   \   <__C446> volatile __io _A_DDRE
   \                     _A_DDRE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2c
   \   <__C449> volatile __io _A_PINE
   \                     _A_PINE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2a
   \   <__C455> volatile __io _A_DDRD
   \                     _A_DDRD:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x27
   \   <__C464> volatile __io _A_DDRC
   \                     _A_DDRC:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x25
   \   <__C470> volatile __io _A_PORTB
   \                     _A_PORTB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x24
   \   <__C473> volatile __io _A_DDRB
   \                     _A_DDRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x21
   \   <__C482> volatile __io _A_DDRA
   \                     _A_DDRA:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char mode
   \                     mode:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char volatile count_bod
   \                     count_bod:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char volatile t_led_on
   \                     t_led_on:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char R[28]
   \                     R:
   \   00000000                      DS8 28
      8          #include <math.h>     
      9          /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
     10          /*                                                                                                          */
     11          /*                                        Главная функция программы                                         */
     12          /*                                                                                                          */
     13          /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

   \                                 In  segment CODE, align 2, keep-with-next
     14          void main( void )
   \                     main:
     15          {
   \   00000000   ........           CALL    ?PROLOGUE8_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
     16            // задание интервала сброса WDT: 
     17            __watchdog_reset();                          // WDTCSR = WDIF WDIE WDP3 WDCE WDE WDP2 WDP1 WDP0 (XXXX XXXX)
   \   00000004   95A8               WDR
     18            WDTCSR |= (1<<WDCE) | (1<<WDE);              // разрешение настройки/системного сброса WDT      (XXX1 1XXX)
   \   00000006   9100....           LDS     R16, _A_WDTCSR
   \   0000000A   6108               ORI     R16, 0x18
   \   0000000C   9300....           STS     _A_WDTCSR, R16
     19            WDTCSR  = (1<<WDE)  | (1<<WDP3);             // установка тайм-аута = 512K циклов (~ 4.0 с)     (0010 1000)  
   \   00000010   E208               LDI     R16, 40
   \   00000012   9300....           STS     _A_WDTCSR, R16
     20            
     21            // инициализация портов:
     22            DDRA = (1<<IN1_01)|(1<<IN1_02)|(1<<IN1_03)|(1<<IN1_04)|(1<<IN1_05)|(1<<IN1_06)|(1<<IN1_07)|(1<<IN1_08); // выходы
   \   00000016   EF0F               LDI     R16, 255
   \   00000018   B901               OUT     0x01, R16
     23            
     24            PORTB = (1<<IN_SS0)|(1<<IN_SS1)|(1<<IN_SS2); // 1 на выходе
   \   0000001A   E301               LDI     R16, 49
   \   0000001C   B905               OUT     0x05, R16
     25            DDRB = (1<<IN_SS0)|(1<<IN_SCK)|(1<<IN_MOSI)|(1<<IN_SS1)|(1<<IN_SS2)|(1<<IN_LE); // выходы
   \   0000001E   E707               LDI     R16, 119
   \   00000020   B904               OUT     0x04, R16
     26            
     27            DDRC = (1<<IN1_09)|(1<<IN1_10)|(1<<IN1_11)|(1<<IN1_12)|(1<<IN1_13)|(1<<IN1_14)|(1<<IN1_15)|(1<<IN1_16); // выходы
   \   00000022   EF0F               LDI     R16, 255
   \   00000024   B907               OUT     0x07, R16
     28          
     29            DDRD = (1<<IN2_01)|(1<<IN2_02)|(1<<IN2_03)|(1<<IN2_04)|(1<<IN2_05)|(1<<IN2_06)|(1<<IN2_07)|(1<<IN2_08); // выходы
   \   00000026   EF0F               LDI     R16, 255
   \   00000028   B90A               OUT     0x0A, R16
     30          
     31            PORTE = (1<<RX)|(1<<TX); // подтяжка на питание или 1 на выходе
   \   0000002A   E003               LDI     R16, 3
   \   0000002C   B90E               OUT     0x0E, R16
     32            DDRE = (1<<TX)|(1<<ADLIN1_D0)|(1<<ADLIN1_D1)|(1<<ADLIN1_D2)|(1<<ADLIN1_D3)|(1<<ADLIN1_D4)|(1<<ADLIN1_D5); // выходы
   \   0000002E   EF0E               LDI     R16, 254
   \   00000030   B90D               OUT     0x0D, R16
     33          
     34            DDRF = (1<<ADLIN1_D6)|(1<<ADLIN2_D0)|(1<<ADLIN2_D1)|(1<<ADLIN2_D2)|(1<<ADLIN2_D3)|(1<<ADLIN2_D4)|(1<<ADLIN2_D5)|(1<<ADLIN2_D6); // выходы
   \   00000032   EF0F               LDI     R16, 255
   \   00000034   BB00               OUT     0x10, R16
     35            
     36            PORTG = (1<<LED); // 1 на выходе
   \   00000036   E200               LDI     R16, 32
   \   00000038   BB04               OUT     0x14, R16
     37            DDRG = (1<<IN4_09)|(1<<IN4_10)|(1<<IN4_11)|(1<<IN4_12)|(1<<IN4_13)|(1<<LED); // выходы
   \   0000003A   E30F               LDI     R16, 63
   \   0000003C   BB03               OUT     0x13, R16
     38            
     39            DDRH = (1<<IN2_09)|(1<<IN2_10)|(1<<IN2_11)|(1<<IN2_12)|(1<<IN2_13)|(1<<IN2_14)|(1<<IN2_15)|(1<<IN2_16); // выходы
   \   0000003E   EF0F               LDI     R16, 255
   \   00000040   9300....           STS     _A_DDRH, R16
     40            
     41            DDRJ = (1<<IN3_01)|(1<<IN3_02)|(1<<IN3_03)|(1<<IN3_04)|(1<<IN3_05)|(1<<IN3_06)|(1<<IN3_07)|(1<<IN3_08); // выходы
   \   00000044   EF0F               LDI     R16, 255
   \   00000046   9300....           STS     _A_DDRJ, R16
     42          
     43            DDRK = (1<<IN3_09)|(1<<IN3_10)|(1<<IN3_11)|(1<<IN3_12)|(1<<IN3_13)|(1<<IN3_14)|(1<<IN3_15)|(1<<IN3_16); // выходы
   \   0000004A   EF0F               LDI     R16, 255
   \   0000004C   9300....           STS     _A_DDRK, R16
     44          
     45            DDRL = (1<<IN4_01)|(1<<IN4_02)|(1<<IN4_03)|(1<<IN4_04)|(1<<IN4_05)|(1<<IN4_06)|(1<<IN4_07)|(1<<IN4_08); // выходы
   \   00000050   EF0F               LDI     R16, 255
   \   00000052   9300....           STS     _A_DDRL, R16
     46          
     47            count_bod = 1;                                  // минимум 1 прерывание
   \   00000056   E001               LDI     R16, 1
   \   00000058   9300....           STS     count_bod, R16
     48            t_led_on  = 0;                                  // время индикации
   \   0000005C   E000               LDI     R16, 0
   \   0000005E   9300....           STS     t_led_on, R16
     49            
     50            __watchdog_reset();                             // 1-й "простой" cброс сторожевого таймера
   \   00000062   95A8               WDR
     51            __enable_interrupt();                           // прерывания разрешаем
   \   00000064   9478               SEI
     52            
     53            // инициализация USART (2400):
     54            UCSR0A = 0x00;                             // запрет настроек USART на время установки скорости передачи
   \   00000066   E000               LDI     R16, 0
   \   00000068   9300....           STS     _A_UCSR0A, R16
     55            UCSR0B = 0x00;                             
   \   0000006C   E000               LDI     R16, 0
   \   0000006E   9300....           STS     _A_UCSR0B, R16
     56            UCSR0C = 0x06;                             // размер слова данных 8 бит
   \   00000072   E006               LDI     R16, 6
   \   00000074   9300....           STS     _A_UCSR0C, R16
     57            UBRR0L = UBBR_2K4L;                        // задание скорости 2400
   \   00000078   E90F               LDI     R16, 159
   \   0000007A   9300....           STS     _A_UBRR0, R16
     58            UBRR0H = UBBR_2K4H;   
   \   0000007E   E001               LDI     R16, 1
   \   00000080   930000C5           STS     197, R16
     59            UCSR0B = 0x08;                             // разрешение передачи (TXENn = 1)
   \   00000084   E008               LDI     R16, 8
   \   00000086   9300....           STS     _A_UCSR0B, R16
     60          
     61            // инициализация Т/С0:
     62            TCCR0B = 0x00;                             // останов Т/С0
   \   0000008A   E000               LDI     R16, 0
   \   0000008C   BD05               OUT     0x25, R16
     63            TCNT0  = RELOAD_TIM0;                      // нач. знач-е
   \   0000008E   E908               LDI     R16, 152
   \   00000090   BD06               OUT     0x26, R16
     64            TCCR0A = 0x00;
   \   00000092   E000               LDI     R16, 0
   \   00000094   BD04               OUT     0x24, R16
     65            TCCR0B = START_TIM0;                       // таймер запускаем
   \   00000096   E004               LDI     R16, 4
   \   00000098   BD05               OUT     0x25, R16
     66            TIMSK0 = 0x01;                             // Т/С0 <- источник прерываний
   \   0000009A   E001               LDI     R16, 1
   \   0000009C   9300....           STS     _A_TIMSK0, R16
     67              
     68            SPI_MasterInit();                          // инициализация SPI в режиме Master
   \   000000A0   ....               RCALL   SPI_MasterInit
     69          //////////////////////////////////////////////////////////////////////////////////////////////////////////////
     70                    
     71                                             //Организация работы линии обмена                   
     72                    
     73          //////////////////////////////////////////////////////////////////////////////////////////////////////////////
     74          /*
     75            Перед началом передачи пакета данных всегда есть синхропауза (логическая 1). Это нужно для безошибочной работы
     76            по линии, т.к. система асинхронная и ведомое устройство может включиться не одновременно с ведущим устройством. 
     77            Даже если устройство включится уже после начала передачи ведущим, оно примет данные только после "полной" 
     78            синхропаузы, которую будет ожидать. Длина синхропаузы больше, чем длина одного слова данных.
     79            Применение асинхронной системы позволяет использовать простой канал связи, который гораздо дешевле, чем при 
     80            синхронной системе. 
     81          */    
     82            for (;;)
     83            {     
     84              UCSR0B &= ~(1<<RXEN0);                   // отключение приемника USART
   \                     ??main_0:
   \   000000A2   910000C1           LDS     R16, 193
   \   000000A6   7E0F               ANDI    R16, 0xEF
   \   000000A8   930000C1           STS     193, R16
     85              count_bod = CBOD;                        // счетчик БОД
   \   000000AC   E004               LDI     R16, 4
   \   000000AE   9300....           STS     count_bod, R16
     86          
     87              do
     88              {
     89          
     90                if (!(PINE & (1<<RX))) count_bod = CBOD;
   \                     ??main_1:
   \   000000B2   9960               SBIC    0x0C, 0x00
   \   000000B4   C003               RJMP    ??main_2
   \   000000B6   E004               LDI     R16, 4
   \   000000B8   9300....           STS     count_bod, R16
     91              } while (count_bod);                     // ожидание СИНХРО-ПАУЗЫ (всегда только перед командой)
   \                     ??main_2:
   \   000000BC   9100....           LDS     R16, count_bod
   \   000000C0   2300               TST     R16
   \   000000C2   F7B9               BRNE    ??main_1
     92          /*
     93              Выполнять присваивание count_bod = CBOD = 4, если RX = 0, пока count_bod - истина. Если же в течение четырёх
     94              периодов переполнения таймера0 с частотой 600 Гц, т.е. 6.7 мс, будет выполнено условие RX = 1, тогда
     95              программа уменьшит значение count_bod до нуля, условие while (count_bod) станет ложным и произойдёт 
     96              выход из цикла do/while. Только теперь устройство включится на приём. Таким образом, значение синхропаузы 
     97              составляет 6.7 мс. Начало приёма происходит при обнаружении старт-бита (логический 0).
     98          */     
     99              // приём данных по UART:
    100          /*
    101              Вперёд старший регистр. Вперёд старший байт.
    102          */
    103              UCSR0B |= (1<<RXEN0);                    // включение приемника USART
   \   000000C4   910000C1           LDS     R16, 193
   \   000000C8   6100               ORI     R16, 0x10
   \   000000CA   930000C1           STS     193, R16
    104               
    105              for(int i=27; i>=0; i--)                 // приём семи 4-х байтовых регистров по UART
   \   000000CE   E10B               LDI     R16, 27
   \   000000D0   E010               LDI     R17, 0
   \                     ??main_3:
   \   000000D2   2311               TST     R17
   \   000000D4   F072               BRMI    ??main_4
    106              {
    107                while (!(UCSR0A & (1<<RXC0)));         // ждем завершение приема байта
   \                     ??main_5:
   \   000000D6   9120....           LDS     R18, _A_UCSR0A
   \   000000DA   2F32               MOV     R19, R18
   \   000000DC   FF37               SBRS    R19, 7
   \   000000DE   CFFB               RJMP    ??main_5
    108                R[i] = UDR0;                           // R6_4, R6_3,...,R6_1,...R0_1
   \   000000E0   9120....           LDS     R18, _A_UDR0
   \   000000E4   01F8               MOVW    R31:R30, R17:R16
   \   000000E6   ....               SUBI    R30, LOW((-(R) & 0xFFFF))
   \   000000E8   ....               SBCI    R31, (-(R) & 0xFFFF) >> 8
   \   000000EA   8320               ST      Z, R18
    109              }
   \   000000EC   5001               SUBI    R16, 1
   \   000000EE   4010               SBCI    R17, 0
   \   000000F0   CFF0               RJMP    ??main_3
    110              
    111              t_led_on  = T_LED_ON;                    // время подсвечивания
   \                     ??main_4:
   \   000000F2   E302               LDI     R16, 50
   \   000000F4   9300....           STS     t_led_on, R16
    112              LED_ON; 
   \   000000F8   98A5               CBI     0x14, 0x05
    113                
    114              // передача данных по SPI на ADF4350:
    115              ClearBit(PORTB, IN_SS0);                 // активация ведомого ADF4350
   \   000000FA   9828               CBI     0x05, 0x00
    116                
    117              for(int j=0; j<=5; j++)
   \   000000FC   2444               CLR     R4
   \   000000FE   2455               CLR     R5
   \                     ??main_6:
   \   00000100   E006               LDI     R16, 6
   \   00000102   1640               CP      R4, R16
   \   00000104   E000               LDI     R16, 0
   \   00000106   0650               CPC     R5, R16
   \   00000108   F53C               BRGE    ??main_7
    118              {  
    119                for(int i=(23-4*j); i>=(20-4*j); i--)  
   \   0000010A   E127               LDI     R18, 23
   \   0000010C   E030               LDI     R19, 0
   \   0000010E   0182               MOVW    R17:R16, R5:R4
   \   00000110   0F00               LSL     R16
   \   00000112   1F11               ROL     R17
   \   00000114   0F00               LSL     R16
   \   00000116   1F11               ROL     R17
   \   00000118   1B20               SUB     R18, R16
   \   0000011A   0B31               SBC     R19, R17
   \   0000011C   0139               MOVW    R7:R6, R19:R18
   \                     ??main_8:
   \   0000011E   E124               LDI     R18, 20
   \   00000120   E030               LDI     R19, 0
   \   00000122   0182               MOVW    R17:R16, R5:R4
   \   00000124   0F00               LSL     R16
   \   00000126   1F11               ROL     R17
   \   00000128   0F00               LSL     R16
   \   0000012A   1F11               ROL     R17
   \   0000012C   1B20               SUB     R18, R16
   \   0000012E   0B31               SBC     R19, R17
   \   00000130   1662               CP      R6, R18
   \   00000132   0673               CPC     R7, R19
   \   00000134   F054               BRLT    ??main_9
    120                { 
    121                  SPI_Write(R[i]);                     // загрузка R5_4, R5_3,...,R5_1,...R0_1 по SPI в 32-разрядный буферный регистр
   \   00000136   01F3               MOVW    R31:R30, R7:R6
   \   00000138   ....               SUBI    R30, LOW((-(R) & 0xFFFF))
   \   0000013A   ....               SBCI    R31, (-(R) & 0xFFFF) >> 8
   \   0000013C   8100               LD      R16, Z
   \   0000013E   ....               RCALL   SPI_Write
    122                }
   \   00000140   EF0F               LDI     R16, 255
   \   00000142   0E60               ADD     R6, R16
   \   00000144   EF0F               LDI     R16, 255
   \   00000146   1E70               ADC     R7, R16
   \   00000148   CFEA               RJMP    ??main_8
    123                
    124                SetBit(PORTB, IN_LE);                  // загрузка данных, хранящихся в регистре сдвига, в один из регистров-защёлок
   \                     ??main_9:
   \   0000014A   9A2E               SBI     0x05, 0x06
    125                ClearBit(PORTB, IN_LE);
   \   0000014C   982E               CBI     0x05, 0x06
    126              }
   \   0000014E   E001               LDI     R16, 1
   \   00000150   0E40               ADD     R4, R16
   \   00000152   E000               LDI     R16, 0
   \   00000154   1E50               ADC     R5, R16
   \   00000156   CFD4               RJMP    ??main_6
    127                
    128              SetBit(PORTB, IN_SS0);                   // деактивация ведомого ADF4350
   \                     ??main_7:
   \   00000158   9A28               SBI     0x05, 0x00
    129                
    130              unsigned char ONE, TWO;
    131                
    132              // передача данных по SPI на hmc1044lp3 Tfcf:
    133          /*
    134              D8D7D6D5D4D3D2D1 D0A3A2A1A0CA2CA1CA0 - 2 байта для передачи по SPI на hmc1044lp3, где
    135              D8D7D6D5D4D3D2D1D0 - данные;
    136              A3A2A1A0 - адрес регистра = 01h;
    137              CA2CA1CA0 - адрес чипа = 110b.
    138          */
    139              ONE = R[27];   // xxxx 1111 
   \   0000015A   9100....           LDS     R16, (R + 27)
   \   0000015E   2F80               MOV     R24, R16
    140              ONE>>=1;       // xxxx x111
   \   00000160   9586               LSR     R24
    141              ONE&=0x7;      // 0000 0111 первый байт - данные без D0
   \   00000162   7087               ANDI    R24, 0x07
    142                
    143              TWO = R[27];   // xxxx 1111
   \   00000164   9100....           LDS     R16, (R + 27)
   \   00000168   2F90               MOV     R25, R16
    144              TWO&=0x1;      // 0000 0001   
   \   0000016A   2F09               MOV     R16, R25
   \   0000016C   2F90               MOV     R25, R16
   \   0000016E   7091               ANDI    R25, 0x01
    145              TWO<<=7;       // 1000 0000
   \   00000170   2F09               MOV     R16, R25
   \   00000172   FB00               BST     R16, 0
   \   00000174   E090               LDI     R25, 0
   \   00000176   F997               BLD     R25, 7
    146              TWO+=0x0E;     // 1000 1110 второй байт - D0, адреса регистра и чипа 
   \   00000178   5F92               SUBI    R25, 242
    147                
    148              ClearBit(PORTB, IN_SS1);                 // активация ведомого hmc1044lp3 Tfcf
   \   0000017A   982C               CBI     0x05, 0x04
    149              SPI_Write(ONE);                          // загрузка ONE по SPI
   \   0000017C   2F08               MOV     R16, R24
   \   0000017E   ....               RCALL   SPI_Write
    150              SPI_Write(TWO);                          // загрузка TWO по SPI 
   \   00000180   2F09               MOV     R16, R25
   \   00000182   ....               RCALL   SPI_Write
    151              SetBit(PORTB, IN_SS1);                   // деактивация ведомого hmc1044lp3 Tfcf
   \   00000184   9A2C               SBI     0x05, 0x04
    152           
    153              // передача данных по SPI на hmc1044lp3 Rfcf:
    154          /*
    155              D8D7D6D5D4D3D2D1 D0A3A2A1A0CA2CA1CA0 - 2 байта для передачи по SPI на hmc1044lp3, где
    156              D8D7D6D5D4D3D2D1D0 - данные;
    157              A3A2A1A0 - адрес регистра = 01h;
    158              CA2CA1CA0 - адрес чипа = 110b.
    159          */      
    160              ONE = R[26];   // xxxx 1111
   \   00000186   9100....           LDS     R16, (R + 26)
   \   0000018A   2F80               MOV     R24, R16
    161              ONE>>=1;       // xxxx x111
   \   0000018C   9586               LSR     R24
    162              ONE&=0x7;      // 0000 0111 первый байт - данные без D0
   \   0000018E   7087               ANDI    R24, 0x07
    163                
    164              TWO = R[26];   // xxxx 1111
   \   00000190   9100....           LDS     R16, (R + 26)
   \   00000194   2F90               MOV     R25, R16
    165              TWO&=0x1;      // 0000 0001      
   \   00000196   2F09               MOV     R16, R25
   \   00000198   2F90               MOV     R25, R16
   \   0000019A   7091               ANDI    R25, 0x01
    166              TWO<<=7;       // 1000 0000
   \   0000019C   2F09               MOV     R16, R25
   \   0000019E   FB00               BST     R16, 0
   \   000001A0   E090               LDI     R25, 0
   \   000001A2   F997               BLD     R25, 7
    167              TWO+=0x0E;     // 1000 1110 второй байт - D0, адреса регистра и чипа
   \   000001A4   5F92               SUBI    R25, 242
    168                
    169              ClearBit(PORTB, IN_SS2);                 // активация ведомого hmc1044lp3 Rfcf
   \   000001A6   982D               CBI     0x05, 0x05
    170              SPI_Write(ONE);                          // загрузка ONE по SPI
   \   000001A8   2F08               MOV     R16, R24
   \   000001AA   ....               RCALL   SPI_Write
    171              SPI_Write(TWO);                          // загрузка TWO по SPI 
   \   000001AC   2F09               MOV     R16, R25
   \   000001AE   ....               RCALL   SPI_Write
    172              SetBit(PORTB, IN_SS2);                   // деактивация ведомого hmc1044lp3 Rfcf
   \   000001B0   9A2D               SBI     0x05, 0x05
    173          
    174              unsigned char temp;
    175                
    176              // передача данных в параллельный порт на ADL5240 Tаf:
    177              temp = R[25];  // xx1x xxxx
   \   000001B2   9100....           LDS     R16, (R + 25)
   \   000001B6   2FA0               MOV     R26, R16
    178              temp>>=5;      // xxxx xxx1
   \   000001B8   95A2               SWAP    R26
   \   000001BA   70AF               ANDI    R26, 0x0F
   \   000001BC   95A6               LSR     R26
    179              temp&=1;       // 0000 0001
   \   000001BE   2F0A               MOV     R16, R26
   \   000001C0   2FA0               MOV     R26, R16
   \   000001C2   70A1               ANDI    R26, 0x01
    180              PORTE |= (temp<<ADLIN1_D1);
   \   000001C4   2F0A               MOV     R16, R26
   \   000001C6   0F00               LSL     R16
   \   000001C8   0F00               LSL     R16
   \   000001CA   0F00               LSL     R16
   \   000001CC   B11E               IN      R17, 0x0E
   \   000001CE   2B10               OR      R17, R16
   \   000001D0   B91E               OUT     0x0E, R17
    181                
    182              temp = R[25];  // xxx1 xxxx
   \   000001D2   9100....           LDS     R16, (R + 25)
   \   000001D6   2FA0               MOV     R26, R16
    183              temp>>=4;      // xxxx xxx1
   \   000001D8   95A2               SWAP    R26
   \   000001DA   70AF               ANDI    R26, 0x0F
    184              temp&=1;       // 0000 0001
   \   000001DC   2F0A               MOV     R16, R26
   \   000001DE   2FA0               MOV     R26, R16
   \   000001E0   70A1               ANDI    R26, 0x01
    185              PORTE |= (temp<<ADLIN1_D2);
   \   000001E2   2F0A               MOV     R16, R26
   \   000001E4   9502               SWAP    R16
   \   000001E6   7F00               ANDI    R16, 0xF0
   \   000001E8   B11E               IN      R17, 0x0E
   \   000001EA   2B10               OR      R17, R16
   \   000001EC   B91E               OUT     0x0E, R17
    186                
    187              temp = R[25];  // xxxx 1xxx
   \   000001EE   9100....           LDS     R16, (R + 25)
   \   000001F2   2FA0               MOV     R26, R16
    188              temp>>=3;      // xxxx xxx1
   \   000001F4   95A6               LSR     R26
   \   000001F6   95A6               LSR     R26
   \   000001F8   95A6               LSR     R26
    189              temp&=1;       // 0000 0001
   \   000001FA   2F0A               MOV     R16, R26
   \   000001FC   2FA0               MOV     R26, R16
   \   000001FE   70A1               ANDI    R26, 0x01
    190              PORTE |= (temp<<ADLIN1_D3);      
   \   00000200   2F0A               MOV     R16, R26
   \   00000202   9502               SWAP    R16
   \   00000204   7F00               ANDI    R16, 0xF0
   \   00000206   0F00               LSL     R16
   \   00000208   B11E               IN      R17, 0x0E
   \   0000020A   2B10               OR      R17, R16
   \   0000020C   B91E               OUT     0x0E, R17
    191                
    192              temp = R[25];  // xxxx x1xx
   \   0000020E   9100....           LDS     R16, (R + 25)
   \   00000212   2FA0               MOV     R26, R16
    193              temp>>=2;      // xxxx xxx1
   \   00000214   95A6               LSR     R26
   \   00000216   95A6               LSR     R26
    194              temp&=1;       // 0000 0001
   \   00000218   2F0A               MOV     R16, R26
   \   0000021A   2FA0               MOV     R26, R16
   \   0000021C   70A1               ANDI    R26, 0x01
    195              PORTE |= (temp<<ADLIN1_D4); 
   \   0000021E   E400               LDI     R16, 64
   \   00000220   9FA0               MUL     R26, R16
   \   00000222   B10E               IN      R16, 0x0E
   \   00000224   2900               OR      R16, R0
   \   00000226   B90E               OUT     0x0E, R16
    196                
    197              temp = R[25];  // xxxx xx1x
   \   00000228   9100....           LDS     R16, (R + 25)
   \   0000022C   2FA0               MOV     R26, R16
    198              temp>>=1;      // xxxx xxx1
   \   0000022E   95A6               LSR     R26
    199              temp&=1;       // 0000 0001
   \   00000230   2F0A               MOV     R16, R26
   \   00000232   2FA0               MOV     R26, R16
   \   00000234   70A1               ANDI    R26, 0x01
    200              PORTE |= (temp<<ADLIN1_D5);      
   \   00000236   2F0A               MOV     R16, R26
   \   00000238   FB00               BST     R16, 0
   \   0000023A   E000               LDI     R16, 0
   \   0000023C   F907               BLD     R16, 7
   \   0000023E   B11E               IN      R17, 0x0E
   \   00000240   2B10               OR      R17, R16
   \   00000242   B91E               OUT     0x0E, R17
    201                
    202              temp = R[25];  // xxxx xxx1
   \   00000244   9100....           LDS     R16, (R + 25)
   \   00000248   2FA0               MOV     R26, R16
    203              temp&=1;       // 0000 0001
   \   0000024A   2F0A               MOV     R16, R26
   \   0000024C   2FA0               MOV     R26, R16
   \   0000024E   70A1               ANDI    R26, 0x01
    204              PORTF |= (temp<<ADLIN1_D6);  
   \   00000250   B301               IN      R16, 0x11
   \   00000252   2B0A               OR      R16, R26
   \   00000254   BB01               OUT     0x11, R16
    205                
    206              // передача данных в параллельный порт на ADL5240 Rаf:
    207              temp = R[24];  // xx1x xxxx
   \   00000256   9100....           LDS     R16, (R + 24)
   \   0000025A   2FA0               MOV     R26, R16
    208              temp>>=5;      // xxxx xxx1
   \   0000025C   95A2               SWAP    R26
   \   0000025E   70AF               ANDI    R26, 0x0F
   \   00000260   95A6               LSR     R26
    209              temp&=1;       // 0000 0001
   \   00000262   2F0A               MOV     R16, R26
   \   00000264   2FA0               MOV     R26, R16
   \   00000266   70A1               ANDI    R26, 0x01
    210              PORTF |= (temp<<ADLIN2_D1);
   \   00000268   2F0A               MOV     R16, R26
   \   0000026A   0F00               LSL     R16
   \   0000026C   0F00               LSL     R16
   \   0000026E   B311               IN      R17, 0x11
   \   00000270   2B10               OR      R17, R16
   \   00000272   BB11               OUT     0x11, R17
    211                
    212              temp = R[24];  // xxx1 xxxx
   \   00000274   9100....           LDS     R16, (R + 24)
   \   00000278   2FA0               MOV     R26, R16
    213              temp>>=4;      // xxxx xxx1
   \   0000027A   95A2               SWAP    R26
   \   0000027C   70AF               ANDI    R26, 0x0F
    214              temp&=1;       // 0000 0001
   \   0000027E   2F0A               MOV     R16, R26
   \   00000280   2FA0               MOV     R26, R16
   \   00000282   70A1               ANDI    R26, 0x01
    215              PORTF |= (temp<<ADLIN2_D2);
   \   00000284   2F0A               MOV     R16, R26
   \   00000286   0F00               LSL     R16
   \   00000288   0F00               LSL     R16
   \   0000028A   0F00               LSL     R16
   \   0000028C   B311               IN      R17, 0x11
   \   0000028E   2B10               OR      R17, R16
   \   00000290   BB11               OUT     0x11, R17
    216                
    217              temp = R[24];  // xxxx 1xxx
   \   00000292   9100....           LDS     R16, (R + 24)
   \   00000296   2FA0               MOV     R26, R16
    218              temp>>=3;      // xxxx xxx1
   \   00000298   95A6               LSR     R26
   \   0000029A   95A6               LSR     R26
   \   0000029C   95A6               LSR     R26
    219              temp&=1;       // 0000 0001
   \   0000029E   2F0A               MOV     R16, R26
   \   000002A0   2FA0               MOV     R26, R16
   \   000002A2   70A1               ANDI    R26, 0x01
    220              PORTF |= (temp<<ADLIN2_D3);      
   \   000002A4   2F0A               MOV     R16, R26
   \   000002A6   9502               SWAP    R16
   \   000002A8   7F00               ANDI    R16, 0xF0
   \   000002AA   B311               IN      R17, 0x11
   \   000002AC   2B10               OR      R17, R16
   \   000002AE   BB11               OUT     0x11, R17
    221                
    222              temp = R[24];  // xxxx x1xx
   \   000002B0   9100....           LDS     R16, (R + 24)
   \   000002B4   2FA0               MOV     R26, R16
    223              temp>>=2;      // xxxx xxx1
   \   000002B6   95A6               LSR     R26
   \   000002B8   95A6               LSR     R26
    224              temp&=1;       // 0000 0001
   \   000002BA   2F0A               MOV     R16, R26
   \   000002BC   2FA0               MOV     R26, R16
   \   000002BE   70A1               ANDI    R26, 0x01
    225              PORTF |= (temp<<ADLIN2_D4); 
   \   000002C0   2F0A               MOV     R16, R26
   \   000002C2   9502               SWAP    R16
   \   000002C4   7F00               ANDI    R16, 0xF0
   \   000002C6   0F00               LSL     R16
   \   000002C8   B311               IN      R17, 0x11
   \   000002CA   2B10               OR      R17, R16
   \   000002CC   BB11               OUT     0x11, R17
    226                
    227              temp = R[24];  // xxxx xx1x
   \   000002CE   9100....           LDS     R16, (R + 24)
   \   000002D2   2FA0               MOV     R26, R16
    228              temp>>=1;      // xxxx xxx1
   \   000002D4   95A6               LSR     R26
    229              temp&=1;       // 0000 0001
   \   000002D6   2F0A               MOV     R16, R26
   \   000002D8   2FA0               MOV     R26, R16
   \   000002DA   70A1               ANDI    R26, 0x01
    230              PORTF |= (temp<<ADLIN2_D5);      
   \   000002DC   E400               LDI     R16, 64
   \   000002DE   9FA0               MUL     R26, R16
   \   000002E0   B301               IN      R16, 0x11
   \   000002E2   2900               OR      R16, R0
   \   000002E4   BB01               OUT     0x11, R16
    231                
    232              temp = R[24];  // xxxx xxx1
   \   000002E6   9100....           LDS     R16, (R + 24)
   \   000002EA   2FA0               MOV     R26, R16
    233              temp&=1;       // 0000 0001
   \   000002EC   2F0A               MOV     R16, R26
   \   000002EE   2FA0               MOV     R26, R16
   \   000002F0   70A1               ANDI    R26, 0x01
    234              PORTF |= (temp<<ADLIN2_D6);      
   \   000002F2   2F0A               MOV     R16, R26
   \   000002F4   FB00               BST     R16, 0
   \   000002F6   E000               LDI     R16, 0
   \   000002F8   F907               BLD     R16, 7
   \   000002FA   B311               IN      R17, 0x11
   \   000002FC   2B10               OR      R17, R16
   \   000002FE   BB11               OUT     0x11, R17
    235               
    236              __watchdog_reset();
   \   00000300   95A8               WDR
   \   00000302   CECF               RJMP    ??main_0
   \   00000304                      REQUIRE _A_DDRL
   \   00000304                      REQUIRE _A_DDRK
   \   00000304                      REQUIRE _A_DDRJ
   \   00000304                      REQUIRE _A_DDRH
   \   00000304                      REQUIRE _A_UDR0
   \   00000304                      REQUIRE _A_UBRR0
   \   00000304                      REQUIRE _A_UCSR0C
   \   00000304                      REQUIRE _A_UCSR0B
   \   00000304                      REQUIRE _A_UCSR0A
   \   00000304                      REQUIRE _A_TIMSK0
   \   00000304                      REQUIRE _A_WDTCSR
   \   00000304                      REQUIRE _A_TCNT0
   \   00000304                      REQUIRE _A_TCCR0B
   \   00000304                      REQUIRE _A_TCCR0A
   \   00000304                      REQUIRE _A_PORTG
   \   00000304                      REQUIRE _A_DDRG
   \   00000304                      REQUIRE _A_PORTF
   \   00000304                      REQUIRE _A_DDRF
   \   00000304                      REQUIRE _A_PORTE
   \   00000304                      REQUIRE _A_DDRE
   \   00000304                      REQUIRE _A_PINE
   \   00000304                      REQUIRE _A_DDRD
   \   00000304                      REQUIRE _A_DDRC
   \   00000304                      REQUIRE _A_PORTB
   \   00000304                      REQUIRE _A_DDRB
   \   00000304                      REQUIRE _A_DDRA
    237            }
    238          }
    239          /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
    240          /*                                                                                                          */
    241          /*                                               Подпрограммы                                               */
    242          /*                                                                                                          */
    243          /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
    244          #pragma vector=TIMER0_OVF_vect         // директива определяет вектор функции прерывания, описание которой следует за ней                 

   \                                 In  segment CODE, align 2, keep-with-next
    245          __interrupt void timer0_ovf_isr(void)  // функция прерывания по переполнению таймера0 
   \                     timer0_ovf_isr:
    246          {
   \   00000000   932A               ST      -Y, R18
   \   00000002   931A               ST      -Y, R17
   \   00000004   930A               ST      -Y, R16
   \   00000006   B71F               IN      R17, 0x3F
   \   00000008   B72B               IN      R18, 0x3B
    247            //TIMER0 has overflowed
    248            TCNT0  = RELOAD_TIM0;                // reload counter value
   \   0000000A   E908               LDI     R16, 152
   \   0000000C   BD06               OUT     0x26, R16
    249          
    250            if (count_bod)  count_bod--;
   \   0000000E   9100....           LDS     R16, count_bod
   \   00000012   2300               TST     R16
   \   00000014   F029               BREQ    ??timer0_ovf_isr_0
   \   00000016   9100....           LDS     R16, count_bod
   \   0000001A   950A               DEC     R16
   \   0000001C   9300....           STS     count_bod, R16
    251          
    252            if(t_led_on)  t_led_on--;            // время подсвечивания --
   \                     ??timer0_ovf_isr_0:
   \   00000020   9100....           LDS     R16, t_led_on
   \   00000024   2300               TST     R16
   \   00000026   F031               BREQ    ??timer0_ovf_isr_1
   \   00000028   9100....           LDS     R16, t_led_on
   \   0000002C   950A               DEC     R16
   \   0000002E   9300....           STS     t_led_on, R16
   \   00000032   C001               RJMP    ??timer0_ovf_isr_2
    253            else          LED_OFF;               // LED-OFF
   \                     ??timer0_ovf_isr_1:
   \   00000034   9AA5               SBI     0x14, 0x05
    254          /*
    255            Частота переполнения таймера0 SYSTEM_TICK выбрана 600 Гц. Поэтому период переполнения таймера0 Tovf 
    256            составляет 1.7 мс, а константа перезагрузки 'TIM0' составляет RELOAD_TIM0 = 152(0x98). Подпрограмма 
    257            обработки прерывания по переполнению таймера0 вызывается каждые 1.7 мс, заново загружает константу 
    258            перезагрузки 'TIM0' и каждый раз уменьшает значение count_bod и t_led_on на единицу, пока значение 
    259            count_bod > 0 и t_led_on > 0. 
    260            Время горения светодиода будет T_LED_ON*Tovf = 120*1.7мс = 0.2c.
    261          */
    262          }
   \                     ??timer0_ovf_isr_2:
   \   00000036   BF2B               OUT     0x3B, R18
   \   00000038   BF1F               OUT     0x3F, R17
   \   0000003A   9109               LD      R16, Y+
   \   0000003C   9119               LD      R17, Y+
   \   0000003E   9129               LD      R18, Y+
   \   00000040   9518               RETI
   \   00000042                      REQUIRE _A_TCNT0
   \   00000042                      REQUIRE _A_PORTG
    263          
    264          // Подпрограмма инициализации SPI в режиме Master

   \                                 In  segment CODE, align 2, keep-with-next
    265          void SPI_MasterInit(void)
   \                     SPI_MasterInit:
    266          {
    267          /* 
    268            - Разрешение SPI в режиме мастера,
    269            - CPOL = 0 - генерируются тактовые импульсы положительной полярности,
    270            - CPHA = 0 - обработка данных производится по переднему фронту импульсов сигнала SCK,
    271            - установка скорости обмена fck/128 
    272          */
    273            SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0);
   \   00000000   E503               LDI     R16, 83
   \   00000002   BD0C               OUT     0x2C, R16
    274          }
   \   00000004   9508               RET
   \   00000006                      REQUIRE _A_SPCR
    275          
    276          // Подпрограмма записи по SPI

   \                                 In  segment CODE, align 2, keep-with-next
    277          void SPI_Write(unsigned char dataout)
   \                     SPI_Write:
    278          {
    279            // Запись байта в регист данных ведущего (инициализация передачи)
    280            SPDR = dataout;
   \   00000000   BD0E               OUT     0x2E, R16
    281            // Ожидание завершения передачи (пока бит SPIF не установлен)
    282            while(!(SPSR & (1<<SPIF)));
   \                     ??SPI_Write_0:
   \   00000002   B51D               IN      R17, 0x2D
   \   00000004   2F21               MOV     R18, R17
   \   00000006   FF27               SBRS    R18, 7
   \   00000008   CFFC               RJMP    ??SPI_Write_0
    283          }
   \   0000000A   9508               RET
   \   0000000C                      REQUIRE _A_SPDR
   \   0000000C                      REQUIRE _A_SPSR

   \                                 In  segment INTVEC, offset 0x5c, root
   \                     `??timer0_ovf_isr??INTVEC 92`:
   \   0000005C   ........           JMP     timer0_ovf_isr

   Maximum stack usage in bytes:

     Function            CSTACK RSTACK
     --------            ------ ------
     SPI_MasterInit          0      2
     SPI_Write               0      2
     main                    8      2
       -> SPI_MasterInit     8      2
       -> SPI_Write          8      2
       -> SPI_Write          8      2
       -> SPI_Write          8      2
       -> SPI_Write          8      2
       -> SPI_Write          8      2
     timer0_ovf_isr          3      2


   Segment part sizes:

     Function/Label              Bytes
     --------------              -----
     Title                         51
     _A_DDRL                        1
     _A_DDRK                        1
     _A_DDRJ                        1
     _A_DDRH                        1
     _A_UDR0                        1
     _A_UBRR0                       2
     _A_UCSR0C                      1
     _A_UCSR0B                      1
     _A_UCSR0A                      1
     _A_TIMSK0                      1
     _A_WDTCSR                      1
     _A_SPDR                        1
     _A_SPSR                        1
     _A_SPCR                        1
     _A_TCNT0                       1
     _A_TCCR0B                      1
     _A_TCCR0A                      1
     _A_PORTG                       1
     _A_DDRG                        1
     _A_PORTF                       1
     _A_DDRF                        1
     _A_PORTE                       1
     _A_DDRE                        1
     _A_PINE                        1
     _A_DDRD                        1
     _A_DDRC                        1
     _A_PORTB                       1
     _A_DDRB                        1
     _A_DDRA                        1
     mode                           1
     count_bod                      1
     t_led_on                       1
     R                             28
     main                         772
     timer0_ovf_isr                66
     SPI_MasterInit                 6
     SPI_Write                     12
     ??timer0_ovf_isr??INTVEC 92    4
      Others                        7

 
  30 bytes in segment ABSOLUTE
 856 bytes in segment CODE
   7 bytes in segment INITTAB
   4 bytes in segment INTVEC
  51 bytes in segment NEAR_F
  31 bytes in segment NEAR_Z
 
 907 bytes of CODE memory (+ 11 bytes shared)
  31 bytes of DATA memory (+ 30 bytes shared)

Errors: none
Warnings: none
